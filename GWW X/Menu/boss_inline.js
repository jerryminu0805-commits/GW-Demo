// __BOSS_BGM_AUDIO_BLOCK__
// Boss BGM audio with unlock & fade helpers
window.__GW_AUDIO__ = window.__GW_AUDIO__ || {};
(() => {
  const store = window.__GW_AUDIO__;

  let fadeTimer = null;
  let pendingPlay = null;
  let forceSilence = false;

  function ensureBossAudio(){
    if (!store.bossBGM) {
      const audio = new Audio('boss_bgm.mp3'); // ← 如果你有不同路径，改这里
      audio.loop = true;
      audio.volume = 0.9;
      store.bossBGM = audio;
    }
    return store.bossBGM;
  }

  function clearFadeTimer(){
    if (fadeTimer) {
      clearInterval(fadeTimer);
      fadeTimer = null;
    }
  }

  function clampVolume(value){
    if (!Number.isFinite(value)) return 0;
    if (value < 0) return 0;
    if (value > 1) return 1;
    return value;
  }

  function hardSilence(audio){
    if (!audio) return;
    try { audio.pause(); } catch (e) {}
    try { audio.currentTime = 0; } catch (e) {}
    try { audio.volume = 0; } catch (e) {}
  }

  function monitorPlay(audio){
    if (!audio) return;
    try {
      const result = audio.play();
      if (result && typeof result.then === 'function') {
        pendingPlay = result;
        result.catch(() => {}).finally(() => {
          if (forceSilence) {
            hardSilence(audio);
          }
          if (pendingPlay === result) {
            pendingPlay = null;
          }
        });
      } else {
        pendingPlay = null;
      }
    } catch (e) {
      pendingPlay = null;
    }
  }

  function fadeVolume(audio, target, ms, options){
    if (!audio) return;
    const opts = options || {};
    target = clampVolume(target);
    const start = clampVolume(audio.volume || 0);
    clearFadeTimer();

    if (!Number.isFinite(ms) || ms <= 0 || Math.abs(target - start) <= 0.0005) {
      audio.volume = target;
      if (opts.stopAtEnd && target <= 0.0005) {
        hardSilence(audio);
      }
      return;
    }

    const steps = Math.max(1, Math.round(ms / 40));
    const stepMs = ms / steps;
    let tick = 0;

    fadeTimer = setInterval(() => {
      tick += 1;
      const progress = Math.min(1, tick / steps);
      const next = start + (target - start) * progress;
      audio.volume = clampVolume(next);
      if (progress >= 0.999) {
        clearFadeTimer();
        audio.volume = target;
        if (opts.stopAtEnd && target <= 0.0005) {
          hardSilence(audio);
        }
      }
    }, stepMs);
  }

  ensureBossAudio();

  if (!store.__unlocked_init__) {
    store.__unlocked_init__ = true;
    window.addEventListener('pointerdown', () => {
      const audio = ensureBossAudio();
      try {
        audio.play().then(() => audio.pause()).catch(() => {});
      } catch (e) {}
      store.unlocked = true;
    }, { once:true });
  }

  store.startBossBGM = function(){
    const audio = ensureBossAudio();
    forceSilence = false;
    clearFadeTimer();
    try { audio.pause(); } catch (e) {}
    try { audio.currentTime = 0; } catch (e) {}
    try { audio.volume = 0; } catch (e) {}
    monitorPlay(audio);
    fadeVolume(audio, 0.9, 600);
  };

  store.stopBossBGM = function(opts){
    const audio = ensureBossAudio();
    forceSilence = true;
    clearFadeTimer();
    const immediate = !!(opts && opts.immediate);
    if (immediate) {
      hardSilence(audio);
      return;
    }
    fadeVolume(audio, 0, 600, { stopAtEnd: true });
  };

  store.forceSilenceBossBGM = function(){
    const audio = ensureBossAudio();
    forceSilence = true;
    clearFadeTimer();
    hardSilence(audio);
  };

  try{
    window.addEventListener('message', (event) => {
      const data = event?.data;
      if(data && data.type === 'GW_FORCE_BOSS_BGM_STOP'){
        try{ store.forceSilenceBossBGM(); }catch(e){}
      }
    });
  }catch(e){}
})();

window.__BOSS_HTML = '<!doctype html>\n<html lang="zh-CN">\n<head>\n  <meta charset="utf-8" />\n  <meta name="viewport" content="width=device-width, initial-scale=1" />\n  <title>2D 回合制 RPG Demo - 七海作战队Boss战<\/title>\n  <style>\n:root {\n  --bg: #0f1115;\n  --panel: #151823;\n  --panel-2: #10131b;\n  --text: #e6e6e6;\n  --muted: #a3a7b3;\n  --accent: #5b8cff;\n  --ok: #52c41a;\n  --warn: #fadb14;\n  --danger: #ff4d4f;\n  --grid-gap: 6px;\n  --cell: 56px; /* 与脚本 CELL_SIZE 对齐 */\n  --board-width: calc(var(--cell) * 22 + var(--grid-gap) * 21 + 18px);\n  --board-height: calc(var(--cell) * 18 + var(--grid-gap) * 17 + 18px);\n  --radius: 10px;\n}\n\n* { box-sizing: border-box; }\nhtml, body { height: 100%; }\nbody {\n  margin: 0;\n  background: linear-gradient(180deg, #0d0f15, #0b0e14 60%, #090c12);\n  color: var(--text);\n  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";\n}\n\n.app {\n  display: grid;\n  grid-template-columns: var(--board-width) 420px;\n  gap: 14px;\n  padding: 16px;\n  width: calc(var(--board-width) + 420px + 14px);\n  max-width: none;\n  margin: 0 auto;\n  justify-content: center;\n}\n\n.left {\n  position: relative;\n  min-width: var(--board-width);\n  max-width: var(--board-width);\n  min-height: var(--board-height);\n  max-height: var(--board-height);\n  background: transparent;\n  overflow: hidden;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: grab;\n}\n\n.left.dragging { cursor: grabbing; }\n\n.board {\n  position: relative; /* largeOverlay 依赖相对定位 */\n  display: grid;\n  /* 行列由脚本动态设置为 18x22 */\n  gap: var(--grid-gap);\n  background: #0c0f15;\n  padding: 8px;\n  border-radius: var(--radius);\n  border: 1px solid #1b2030;\n  box-shadow: 0 10px 30px rgba(0,0,0,0.25) inset;\n  transform-origin: center center;\n  transform: scale(var(--cam-scale, 1)) translate3d(var(--cam-tx, 0px), var(--cam-ty, 0px), 0);\n}\n\n.board.shake {\n  animation: boardShake 0.22s ease-in-out;\n}\n\n@keyframes boardShake {\n  0% { transform: scale(var(--cam-scale, 1)) translate3d(calc(var(--cam-tx, 0px) + 2px), calc(var(--cam-ty, 0px) + 0px), 0); }\n  25% { transform: scale(var(--cam-scale, 1)) translate3d(calc(var(--cam-tx, 0px) - 2px), calc(var(--cam-ty, 0px) + 1px), 0); }\n  50% { transform: scale(var(--cam-scale, 1)) translate3d(calc(var(--cam-tx, 0px) + 2px), calc(var(--cam-ty, 0px) - 1px), 0); }\n  75% { transform: scale(var(--cam-scale, 1)) translate3d(calc(var(--cam-tx, 0px) - 1px), calc(var(--cam-ty, 0px) + 2px), 0); }\n  100% { transform: scale(var(--cam-scale, 1)) translate3d(var(--cam-tx, 0px), var(--cam-ty, 0px), 0); }\n}\n\n.cell {\n  position: relative;\n  width: var(--cell);\n  height: var(--cell);\n  background: #141a26;\n  border-radius: 8px;\n  border: 1px solid #1e2536;\n  transition: background .12s ease, transform .12s ease, box-shadow .12s ease, opacity .12s ease;\n  overflow: hidden;\n}\n.cell .coord {\n  position: absolute;\n  left: 6px;\n  top: 4px;\n  font-size: 11px;\n  color: var(--muted);\n  opacity: .6;\n}\n.cell.highlight-move { outline: 2px dashed #7cb305; outline-offset: -3px; }\n.cell.highlight-skill { outline: 2px solid #40a9ff; outline-offset: -3px; }\n.cell.highlight-skill-target { outline: 2px solid #ff7875; outline-offset: -3px; }\n.cell.pulse { box-shadow: 0 0 0 3px rgba(255,255,0,0.25) inset; }\n\n/* 右下 void 与掩体 cover 样式 */\n.cell.void {\n  background: repeating-linear-gradient(45deg, #0b0e14, #0b0e14 8px, #0a0d13 8px, #0a0d13 16px);\n  border-color: #121621;\n  opacity: 0.45;\n  pointer-events: none;\n}\n.cell.cover {\n  background: #1a2030;\n  border-color: #2a3756;\n  box-shadow: 0 0 0 2px rgba(90,120,180,0.18) inset;\n  pointer-events: none; /* 掩体不可进入 */\n}\n\n/* 1x1 单位：放在 cell 内，绝对定位铺满 cell */\n.unit {\n  position: absolute;\n  inset: 0;\n  display: grid;\n  grid-template-rows: 1fr auto auto;\n  place-items: center;\n  color: #fff;\n  font-size: 12px;\n  text-align: center;\n  padding: 4px;\n}\n.unit.player { background: rgba(91,140,255,0.08); border: 1px solid rgba(91,140,255,0.3); }\n.unit.enemy  { background: rgba(255,77,79,0.08); border: 1px solid rgba(255,77,79,0.3); }\n\n.hpbar, .spbar { width: 90%; height: 10px; background: #0e121b; border-radius: 99px; overflow: hidden; border: 1px solid #1c2334; margin: 2px 0; }\n.hpfill { height: 100%; background: linear-gradient(90deg, #ff7875, #ff4d4f); }\n.spfill { height: 100%; background: linear-gradient(90deg, #36cfc9, #13c2c2); }\n\n.unit .facing-arrow,\n.largeOverlay .facing-arrow {\n  position: absolute;\n  left: 50%;\n  width: 16px;\n  height: 16px;\n  pointer-events: none;\n  opacity: 0.6;\n  filter: drop-shadow(0 1px 2px rgba(0,0,0,0.4));\n  transform: translate(-50%, 0) rotate(0deg);\n  transition: transform .18s ease;\n}\n.unit .facing-arrow { bottom: 4px; }\n.largeOverlay .facing-arrow { bottom: 10px; }\n\n.unit .facing-arrow::before,\n.largeOverlay .facing-arrow::before {\n  content: \'\';\n  display: block;\n  width: 100%;\n  height: 100%;\n  clip-path: polygon(0% 50%, 55% 12%, 100% 50%, 55% 88%);\n  background: linear-gradient(135deg, rgba(255,255,255,0.85), rgba(255,255,255,0.2));\n}\n\n.unit.player .facing-arrow::before,\n.largeOverlay.player .facing-arrow::before {\n  background: linear-gradient(135deg, rgba(91,140,255,0.75), rgba(91,140,255,0.18));\n}\n\n.unit.enemy .facing-arrow::before,\n.largeOverlay.enemy .facing-arrow::before {\n  background: linear-gradient(135deg, rgba(255,77,79,0.75), rgba(255,77,79,0.22));\n}\n\n.unit[data-facing="left"] .facing-arrow,\n.largeOverlay[data-facing="left"] .facing-arrow {\n  transform: translate(-50%, 0) rotate(180deg);\n}\n\n.unit[data-facing="up"] .facing-arrow,\n.largeOverlay[data-facing="up"] .facing-arrow {\n  transform: translate(-50%, 0) rotate(-90deg);\n}\n\n.unit[data-facing="down"] .facing-arrow,\n.largeOverlay[data-facing="down"] .facing-arrow {\n  transform: translate(-50%, 0) rotate(90deg);\n}\n\n/* 2x2 大单位（如 Tusk）绝对定位覆盖层：不参与 Grid 排版 */\n.largeOverlay {\n  position: absolute;\n  background: rgba(255,77,79,0.08);\n  border: 1px solid rgba(255,77,79,0.35);\n  border-radius: 10px;\n  color: #e9eefc;\n  display: grid;\n  grid-template-rows: auto auto auto;\n  place-items: center;\n  padding: 6px 8px;\n  pointer-events: none; /* 允许点击穿透到下方格子与单位 */\n  z-index: 50;\n}\n.largeOverlay.player {\n  background: rgba(91,140,255,0.08);\n  border-color: rgba(91,140,255,0.35);\n}\n.largeOverlay .title { font-weight: 600; }\n.largeOverlay .hpbar, .largeOverlay .spbar { width: 88%; }\n\n.cameraControls {\n  position: absolute;\n  right: 16px;\n  bottom: 16px;\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n  z-index: 1200;\n}\n\n.cameraControls button {\n  width: 42px;\n  height: 42px;\n  border-radius: 50%;\n  border: 1px solid rgba(255,255,255,0.15);\n  background: rgba(17,24,36,0.7);\n  color: #dbe7ff;\n  font-size: 18px;\n  cursor: pointer;\n  transition: background .15s ease, transform .15s ease;\n  backdrop-filter: blur(4px);\n}\n\n.cameraControls button:hover { background: rgba(41,58,85,0.75); transform: translateY(-1px); }\n.cameraControls button:active { transform: scale(0.94); }\n\n.introDialog {\n  position: fixed;\n  inset: 0;\n  display: flex;\n  align-items: flex-end;\n  justify-content: center;\n  background: rgba(6, 8, 12, 0.65);\n  z-index: 5000;\n  backdrop-filter: blur(4px);\n}\n\n.introDialog .box { position: absolute; left: 50%; transform: translateX(-50%); bottom: 32px; width: min(960px, 86vw);\n  background: rgba(13, 18, 28, 0.92);\n  border: 1px solid rgba(91, 140, 255, 0.35);\n  border-radius: 12px;\n  padding: 28px 36px;\n  max-width: 480px;\n  font-size: 18px;\n  line-height: 1.6;\n  color: #f0f3ff;\n  box-shadow: 0 20px 48px rgba(0,0,0,0.45);\n  text-align: center;\n  position: relative;\n}\n\n.introDialog .hint {\n  margin-top: 18px;\n  font-size: 14px;\n  color: rgba(219, 231, 255, 0.7);\n}\n\n.roundBanner { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; pointer-events: none; z-index: 4000; opacity: 0; transform: translateY(12px) scale(0.98); transition: opacity .85s ease, transform .85s ease; }\n\n.roundBanner.show { opacity: 1; transform: translateY(0) scale(1); }\n\n.roundBanner .text {\n  font-size: 96px;\n  font-weight: 800;\n  letter-spacing: 12px;\n  color: rgba(255,255,255,1);\n  text-shadow: 0 0 2px rgba(0,0,0,0.75), 0 0 28px rgba(91,140,255,0.60), 0 0 64px rgba(91,140,255,0.40);\n}\n\n.right {\n  display: grid;\n  grid-template-rows: auto 1fr;\n  gap: 14px;\n}\n.panel {\n  background: var(--panel);\n  border: 1px solid #22293b;\n  border-radius: var(--radius);\n  padding: 12px;\n  box-shadow: 0 10px 30px rgba(0,0,0,.25);\n}\n.logPanel { background: var(--panel-2); }\n\n.steps { color: var(--muted); margin-bottom: 8px; }\n.section { margin-top: 10px; }\n.section h3 { margin: 6px 0 8px; font-size: 14px; color: #b6bdd1; }\n\n.partyRow { font-size: 13px; padding: 3px 0; color: #d7d9e0; }\n.partyRow.small { font-size: 12px; color: #aeb6c9; }\n\n.skillPool {\n  display: grid;\n  grid-template-columns: 1fr;\n  gap: 8px;\n  max-height: 360px;\n  overflow: auto;\n  padding-right: 4px;\n}\n.skillCard {\n  background: #131926;\n  border: 1px solid #1d2436;\n  border-left: 6px solid #52c41a;\n  border-radius: 8px;\n  padding: 8px;\n  cursor: pointer;\n  display: block;\n  transition: transform .12s ease, border-color .12s ease, background .12s ease;\n}\n.skillCard.green { border-left-color: #52c41a; }\n.skillCard.red { border-left-color: #ff7875; }\n.skillCard.blue { border-left: 6px solid #1890ff !important; }\n.skillCard.orange { border-left-color: #fa8c16; }\n.skillCard:hover { transform: translateY(-1px); background: #141c2b; }\n.skillCard.disabled { opacity: .6; filter: grayscale(0.1); cursor: not-allowed; }\n\n.skillCard .discardBtn {\n  background: #24304a;\n  color: #dbe5ff;\n  border: 1px solid #324064;\n  border-radius: 6px;\n}\n.skillCard .discardBtn:hover { background: #2a3857; }\n\n.actions { margin-top: 10px; }\n.actions button {\n  width: 100%;\n  padding: 10px 14px;\n  font-weight: 700;\n  font-size: 14px;\n  color: #fff;\n  background: linear-gradient(90deg, #5b8cff, #6e74ff);\n  border: none;\n  border-radius: 8px;\n  cursor: pointer;\n  box-shadow: 0 8px 20px rgba(107,141,255,.25);\n}\n.actions button:hover { filter: brightness(1.05); }\n\n.log {\n  height: 360px;\n  overflow: auto;\n  font-size: 13px;\n  line-height: 1.4;\n  padding: 8px;\n  background: #0d1320;\n  border-radius: 8px;\n  border: 1px solid #1b2234;\n  display: flex;\n  flex-direction: column-reverse; /* 最新在上 */\n}\n.log > div { padding: 3px 0; color: #d8def0; }\n\n/* 胜利弹窗 */\n.modal.hidden { display: none; }\n.modal {\n  position: fixed;\n  inset: 0;\n  display: grid;\n  place-items: center;\n  background: rgba(0,0,0,0.35);\n  z-index: 9999;\n}\n.modal-content {\n  width: min(520px, 92vw);\n  background: #121726;\n  border: 1px solid #1f2840;\n  border-radius: 12px;\n  padding: 16px;\n  color: #e6e9f4;\n}\n.modal-actions { margin-top: 12px; display: flex; justify-content: flex-end; }\n.modal-actions button {\n  background: #2b3a5f;\n  color: #dfe7ff;\n  border: 1px solid #394a75;\n  padding: 8px 12px;\n  border-radius: 8px;\n  cursor: pointer;\n}\n.modal-actions button:hover { filter: brightness(1.06); }\n\n/* 滚动条微样式（WebKit） */\n.skillPool::-webkit-scrollbar,\n.log::-webkit-scrollbar { width: 8px; }\n.skillPool::-webkit-scrollbar-thumb,\n.log::-webkit-scrollbar-thumb { background: #2a3350; border-radius: 6px; }\n/* Arknights-style speaker tag */\n.introDialog .box { padding: 18px 24px 20px 24px; }\n.introDialog .box .speaker {\n  position: absolute;\n  left: 16px;\n  top: -14px;\n  padding: 4px 10px;\n  background: linear-gradient(90deg, #2b3040, #1a1f2d);\n  border: 1px solid #39415a;\n  border-radius: 8px;\n  font-size: 13px;\n  color: #e8eefc;\n  letter-spacing: .5px;\n  box-shadow: 0 6px 16px rgba(0,0,0,.35);\n}\n.introDialog .box .content { font-size: 16px; text-align: left; }\n\n/* Haz subtle red glow + stronger glow on comeback */\n.unit.haz-glow {\n  box-shadow: 0 0 10px rgba(255, 88, 88, 0.35), inset 0 0 8px rgba(255,0,0,0.18);\n}\n.unit.haz-glow.comeback {\n  box-shadow: 0 0 18px rgba(255, 78, 78, 0.7), 0 0 36px rgba(255, 40, 40, 0.35), inset 0 0 12px rgba(255,0,0,0.28);\n  position: relative;\n}\n.unit.haz-glow.comeback::before,\n.unit.haz-glow.comeback::after {\n  content: "";\n  position: absolute;\n  bottom: 6px;\n  width: 3px;\n  height: 14px;\n  background: radial-gradient(circle, rgba(255,140,140,0.9) 0%, rgba(255,140,140,0.0) 70%);\n  filter: blur(1px);\n  animation: hazRise 1.3s linear infinite;\n  opacity: 0.8;\n}\n.unit.haz-glow.comeback::before { left: 35%; animation-delay: 0.0s; }\n.unit.haz-glow.comeback::after  { left: 62%; animation-delay: 0.5s; }\n\n@keyframes hazRise {\n  0%   { transform: translateY(8px) scale(0.8); opacity: 0; }\n  40%  { opacity: 0.9; }\n  100% { transform: translateY(-18px) scale(1.0); opacity: 0; }\n}\n\n/* Intro dialog centering & size fix */\n.introDialog {\n  position: fixed;\n  left: 0; right: 0; bottom: 0;\n  display: flex;\n  justify-content: center;\n  pointer-events: none;\n  z-index: 5000;\n}\n.introDialog .box {\n  position: relative;\n  width: min(1100px, 92vw);\n  min-height: 150px; /* 拉长往下 */\n  margin: 0 auto 28px auto;\n  pointer-events: auto;\n}\n.introDialog .content {\n  font-size: 16px;\n  line-height: 1.6;\n  padding-top: 6px;\n}\n/* Haz 名字小牌位于对话框左上角 */\n.introDialog .speaker {\n  position: absolute;\n  left: 16px;\n  top: -16px;\n}\n\n/* Force center-bottom for intro dialog box; reset legacy props */\n.introDialog .box {\n  position: relative !important;\n  left: auto !important;\n  right: auto !important;\n  bottom: auto !important;\n  transform: none !important;\n  margin: 0 auto 28px auto !important;\n}\n\n/* Center-bottom intro dialog box (absolute) */\n.introDialog { align-items: flex-end !important; justify-content: center !important; }\n.introDialog .box {\n  position: fixed !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n  bottom: 32px !important;\n  width: min(1100px, 92vw) !important;\n  min-height: 150px !important;\n  margin: 0 auto !important;\n}\n.introDialog .speaker { left: 16px !important; top: -16px !important; }\n\n<\/style>\n<\/head>\n<body>\n  <div id="battleCamera">\n    <div class="app">\n      <div class="left" id="mapPane">\n        <div id="battleArea" class="board"><\/div>\n      <\/div>\n      <div class="right">\n        <div class="panel">\n          <div class="steps">\n            玩家步数: <span id="playerSteps">0<\/span> | 敌方步数: <span id="enemySteps">0<\/span> | 回合: <span id="roundCount">0<\/span>\n          <\/div>\n          <div class="section">\n            <h3>队伍状态<\/h3>\n            <div id="partyStatus"><\/div>\n          <\/div>\n          <div class="section">\n            <h3>当前选择<\/h3>\n            <div id="selectedInfo"><\/div>\n          <\/div>\n          <div class="section">\n            <h3>手牌<\/h3>\n            <div id="skillPool" class="skillPool"><\/div>\n          <\/div>\n          <div class="actions">\n            <button id="endTurnBtn">结束回合<\/button>\n          <\/div>\n        <\/div>\n        <div class="panel logPanel">\n          <h3>战斗日志<\/h3>\n          <div id="log" class="log"><\/div>\n        <\/div>\n      <\/div>\n    <\/div>\n  <\/div>\n\n  <div id="accomplish" class="modal hidden">\n    <div class="modal-content">\n      <h2>战斗胜利！<\/h2>\n      <div id="damageSummary"><\/div>\n      <div class="modal-actions">\n        <button id="confirmBtn">确定<\/button>\n      <\/div>\n    <\/div>\n  <\/div>\n\n  <script src="script.js"><\/script>\n<script>\n// 2D 回合制 RPG Demo - 七海作战队Boss战\n// 变更摘要：\n// - 注入基础栅格/单位样式与 --cell 默认值，修复“又没角色了”（无 CSS 时看不到格子/单位）。\n// - AI：加入 BFS 寻路与兜底移动，避免整轮只动队长或卡住不用完步数。\n// - 多阶段技能：每一阶段即时演出与结算（青→红→结算→黄阶段标记）。\n// - Adora：略懂的医术！；电击装置会叠1层眩晕叠层与恐惧减步。\n// - Karma：深呼吸 被动+10% 只要卡在池里未被使用，主动用为回蓝+10HP。\n// - UI：新增 Full Screen（全屏）按钮，支持原生全屏与模拟全屏双方案；修复 2x2 单位（Tusk）初始可能不在视区的覆盖刷新。\n// - GOD’S WILL：增强健壮性（按钮/菜单/点击单位三路触发），并在全屏/窗口变化后稳定可用。\n// - Neyla：压迫后“终末之影”规则：每回合保证手牌至多一张；如无且卡满则随机替换一张为“终末之影”。\n// - 调整：双钩牵制 → Neyla 常态技能（2步，红，前3格内优先最近，单体）；终焉礼炮不再标注为压迫技能（常态/压迫均可用）。\n// - 调整：Katz「反复鞭尸」→ 3步 前3格AOE，10/15伤害+每段+5SP，按自身SP百分比重复（最多5次），出现率50%，压迫后不再出现。\n// - 调整：Neyla 常态也可抽到「终末之影」（30%）。\n// - 调整：Kyn「影杀之舞」→ 常态2步 3x3 AOE 30伤害（不受掩体）并立即免费位移1格（50%），压迫后不再出现；压迫后新增「自我了断。。」。\n// - 状态栏：被“猎杀标记”的单位在 Debuff 栏显示“猎杀标记”。\n// - 修复：Tusk（2x2）被点击锁定时，技能指向将智能映射到其四个覆盖格之一，避免“进入姿态后无法被选中/命中”（具体逻辑在 part2 的 overlay 点击处理）。\n// - 新增保证：在“敌方回合结束，玩家回合开始”之前，敌方必定把步数用到 0（若无技能则自动向玩家单位逼近），详见 part2 的 exhaustEnemySteps 与 finishEnemyTurn 逻辑。\n\nlet ROWS = 18;\nlet COLS = 22;\n\nconst CELL_SIZE = 56;\nconst GRID_GAP = 6;\nconst BOARD_PADDING = 8;\nconst BOARD_BORDER = 1;\nconst BOARD_WIDTH = COLS * CELL_SIZE + (COLS - 1) * GRID_GAP + (BOARD_PADDING + BOARD_BORDER) * 2;\nconst BOARD_HEIGHT = ROWS * CELL_SIZE + (ROWS - 1) * GRID_GAP + (BOARD_PADDING + BOARD_BORDER) * 2;\nconst MAX_STEPS = 10;\nconst BASE_START_STEPS = 3;\nconst SKILLPOOL_MAX = 13;\nconst START_HAND_COUNT = 3;\n\nconst ENEMY_IS_AI_CONTROLLED = true;\nconst ENEMY_WINDUP_MS = 850;\n\n// Telegraph/Impact Durations\nconst TELEGRAPH_MS = 520;\nconst IMPACT_MS    = 360;\nconst STAGE_MS     = 360;\n\nconst DEBUG_AI = false;\nfunction aiLog(u,msg){ if(DEBUG_AI) appendLog(`[AI] ${u.name}: ${msg}`); }\n\nconst inventory = { pistol: false };\n\nlet roundsPassed = 0;\nlet playerBonusStepsNextTurn = 0;\nfunction computeBaseSteps(){ return Math.min(BASE_START_STEPS + roundsPassed, MAX_STEPS); }\n\nlet playerSteps = computeBaseSteps();\nlet enemySteps = computeBaseSteps();\nlet currentSide = \'player\';\n\nlet selectedUnitId = null;\nlet highlighted = new Set();\nlet logEl;\n\nlet _skillSelection = null;\nlet fxLayer = null;\nlet cameraEl = null;\nlet battleAreaEl = null;\nlet mapPaneEl = null;\nlet cameraControlsEl = null;\nlet roundBannerEl = null;\nlet introDialogEl = null;\n\nlet playerStepsEl, enemyStepsEl, roundCountEl, partyStatus, selectedInfo, skillPool, accomplish, damageSummary;\n\nlet hazMarkedTargetId = null;\n\nlet interactionLocked = false;\nlet introPlayed = false;\nlet cameraResetTimer = null;\nlet enemyActionCameraLock = false;\nlet cameraLoopHandle = null;\nlet cameraDragState = null;\nlet cameraInputsRegistered = false;\n\nconst cameraState = {\n  x: 0,\n  y: 0,\n  scale: 1,\n  targetX: 0,\n  targetY: 0,\n  targetScale: 1,\n  vx: 0,\n  vy: 0,\n  vs: 0,\n  baseScale: 1,\n  minScale: 0.6,\n  maxScale: 1.6,\n};\n\n// GOD\'S WILL\nlet godsWillArmed = false;\nlet godsWillMenuEl = null;\nlet godsWillBtn = null;\nlet godsWillUnlocked = false;\nlet godsWillLockedOut = false;\nconst GODS_WILL_PASSWORD = \'745876\';\n\n// Fullscreen\nlet fsBtn = null;\nlet isSimFullscreen = false;\n\n// AI Watchdog\nlet aiLoopToken = 0;\nlet aiWatchdogTimer = null;\nfunction armAIWatchdog(token, ms=12000){\n  if(aiWatchdogTimer) clearTimeout(aiWatchdogTimer);\n  aiWatchdogTimer = setTimeout(()=>{\n    if(token === aiLoopToken && currentSide === \'enemy\'){\n      appendLog(\'AI 看门狗触发：强制结束敌方回合\');\n      enemySteps = 0; updateStepsUI();\n      finishEnemyTurn();\n    }\n  }, ms);\n}\nfunction clearAIWatchdog(){ if(aiWatchdogTimer){ clearTimeout(aiWatchdogTimer); aiWatchdogTimer=null; } }\n\n// —— 地图/掩体 ——\nfunction toRC_FromBottomLeft(x, y){ const c = x + 1; const r = ROWS - y; return { r, c }; }\nfunction isVoidCell(r,c){\n  const voidRStart = ROWS - 8 + 1; // 11\n  const voidCStart = COLS - 10 + 1; // 13\n  return (r >= voidRStart && c >= voidCStart);\n}\nconst coverCells = new Set();\nfunction addCoverRectBL(x1,y1,x2,y2){\n  const xmin = Math.min(x1,x2), xmax = Math.max(x1,x2);\n  const ymin = Math.min(y1,y2), ymax = Math.max(y1,y2);\n  for(let x=xmin; x<=xmax; x++){\n    for(let y=ymin; y<=ymax; y++){\n      const {r,c} = toRC_FromBottomLeft(x,y);\n      if(r>=1 && r<=ROWS && c>=1 && c<=COLS && !isVoidCell(r,c)){\n        coverCells.add(`${r},${c}`);\n      }\n    }\n  }\n}\nfunction isCoverCell(r,c){ return coverCells.has(`${r},${c}`); }\nfunction clampCell(r,c){ return r>=1 && r<=ROWS && c>=1 && c<=COLS && !isVoidCell(r,c) && !isCoverCell(r,c); }\n\n// —— 单位 ——\nfunction createUnit(id, name, side, level, r, c, maxHp, maxSp, restoreOnZeroPct, spZeroHpPenalty=0, passives=[], extra={}){\n  return {\n    id, name, side, level, r, c,\n    size: extra.size || 1,\n    hp: maxHp, maxHp,\n    sp: maxSp, maxSp,\n    restoreOnZeroPct, spZeroHpPenalty,\n    facing: side===\'player\' ? \'right\' : \'left\',\n    status: {\n      stunned: 0,\n      paralyzed: 0,\n      bleed: 0,\n      hazBleedTurns: 0,\n      recoverStacks: 0,          // “恢复”Buff 层数（每大回合开始消耗一层，+5HP）\n      jixueStacks: 0,            // “鸡血”Buff 层数（下一次攻击伤害x2）\n      dependStacks: 0,           // “依赖”Buff 层数（下一次攻击真实伤害，结算后清空自身SP）\n    },\n    dmgDone: 0,\n    skillPool: [],\n    passives: passives.slice(),\n    actionsThisTurn: 0,\n    consecAttacks: 0,\n    turnsStarted: 0,\n    dealtStart: false,\n    team: extra.team || null,\n    oppression: false,\n    chainShieldTurns: 0,\n    chainShieldRetaliate: 0,\n    tuskRageStacks: 0,\n    stunThreshold: extra.stunThreshold || 1,\n    _staggerStacks: 0,\n    pullImmune: !!extra.pullImmune,\n    _spBroken: false,\n    _spCrashVuln: false,\n    spPendingRestore: null,\n    _comeback: false,\n\n    // 姿态系统（Tusk等）\n    _stanceType: null,        // \'defense\' | \'retaliate\' | null\n    _stanceTurns: 0,\n    _stanceDmgRed: 0,         // 0.5 表示50%减伤\n    _stanceSpPerTurn: 0,\n    _reflectPct: 0,           // 0.3 表示反弹30%受到的HP伤害\n\n    _fortressTurns: 0, // 兼容旧逻辑（已由姿态系统替代）\n  };\n}\nconst units = {};\n// 玩家\nunits[\'adora\'] = createUnit(\'adora\',\'Adora\',\'player\',52, 17, 2, 100,100, 0.5,0, [\'backstab\',\'calmAnalysis\',\'proximityHeal\',\'fearBuff\']);\nunits[\'dario\'] = createUnit(\'dario\',\'Dario\',\'player\',52, 17, 6, 150,100, 0.75,0, [\'quickAdjust\',\'counter\',\'moraleBoost\']);\nunits[\'karma\'] = createUnit(\'karma\',\'Karma\',\'player\',52, 17, 4, 200,50, 0.5,20, [\'violentAddiction\',\'toughBody\',\'pride\']);\n// 七海\nfunction applyAftermath(u){ u.hp = Math.max(1, Math.floor(u.hp * 0.75)); if(!u.passives.includes(\'aftermath\')) u.passives.push(\'aftermath\'); }\nunits[\'haz\']  = createUnit(\'haz\',\'Haz\',\'enemy\',55, 4,21, 750,100, 1.0,0, [\'hazObsess\',\'hazHatred\',\'hazOrders\',\'hazWorth\',\'hazCritWindow\',\'hazHunt\'], {team:\'seven\', stunThreshold:4, pullImmune:true}); applyAftermath(units[\'haz\']);\nunits[\'katz\'] = createUnit(\'katz\',\'Katz\',\'enemy\',53, 3,19, 500,75, 1.0,0, [\'katzHidden\',\'katzExecution\',\'katzStrong\'], {team:\'seven\', stunThreshold:3, pullImmune:true}); applyAftermath(units[\'katz\']);\nunits[\'tusk\'] = createUnit(\'tusk\',\'Tusk\',\'enemy\',54, 6,19, 1000,60, 1.0,0, [\'tuskGuard\',\'tuskWall\',\'tuskBull\'], {team:\'seven\', size:2, stunThreshold:3, pullImmune:true}); applyAftermath(units[\'tusk\']);\nunits[\'neyla\']= createUnit(\'neyla\',\'Neyla\',\'enemy\',52, 2,15, 350,80, 1.0,0, [\'neylaAim\',\'neylaCold\',\'neylaReload\'], {team:\'seven\', stunThreshold:2}); applyAftermath(units[\'neyla\']);\nunits[\'kyn\']  = createUnit(\'kyn\',\'Kyn\',\'enemy\',51, 7,15, 250,70, 1.0,0, [\'kynReturn\',\'kynExecute\',\'kynSwift\'], {team:\'seven\', stunThreshold:2}); applyAftermath(units[\'kyn\']);\n\n// —— 范围/工具 ——\nconst DIRS = { up:{dr:-1,dc:0}, down:{dr:1,dc:0}, left:{dr:0,dc:-1}, right:{dr:0,dc:1} };\nfunction mdist(a,b){ return Math.abs(a.r-b.r)+Math.abs(a.c-b.c); }\nfunction cardinalDirFromDelta(dr,dc){ if(Math.abs(dr)>=Math.abs(dc)) return dr<=0?\'up\':\'down\'; return dc<=0?\'left\':\'right\'; }\nfunction setUnitFacing(u, dir){ if(!u || !dir) return; if(!DIRS[dir]) return; u.facing = dir; }\nfunction clampValue(value, min, max){ return Math.max(min, Math.min(max, value)); }\nfunction forwardCellAt(u, dir, dist){\n  const d=DIRS[dir]; const r=u.r + d.dr*dist, c=u.c + d.dc*dist;\n  if(u.size===2){ if(clampCell(r,c) && clampCell(r+1,c+1)) return {r,c}; return null; }\n  if(clampCell(r,c)) return {r,c};\n  return null;\n}\nfunction forwardLineAt(u, dir){\n  const arr=[]; const d=DIRS[dir]; let r=u.r+d.dr, c=u.c+d.dc;\n  while(true){\n    if(u.size===2){ if(!(clampCell(r,c) && clampCell(r+1,c+1))) break; }\n    else if(!clampCell(r,c)) break;\n    arr.push({r,c}); r+=d.dr; c+=d.dc;\n  }\n  return arr;\n}\nfunction range_adjacent(u){\n  const res=[];\n  if(u.size===2){\n    const cand = [\n      {r:u.r-1, c:u.c}, {r:u.r-1, c:u.c+1},\n      {r:u.r+2, c:u.c}, {r:u.r+2, c:u.c+1},\n      {r:u.r, c:u.c-1}, {r:u.r+1, c:u.c-1},\n      {r:u.r, c:u.c+2}, {r:u.r+1, c:u.c+2},\n    ];\n    for(const p of cand){ if(clampCell(p.r,p.c)) res.push({...p, dir: cardinalDirFromDelta(p.r-u.r, p.c-u.c)}); }\n  } else {\n    for(const k in DIRS){ const d=DIRS[k]; const r=u.r+d.dr, c=u.c+d.dc; if(clampCell(r,c)) res.push({r,c,dir:k}); }\n  }\n  return res;\n}\nfunction range_forward_n(u,n, aimDir){ const dir=aimDir||u.facing; const arr=[]; for(let i=1;i<=n;i++){ const c=forwardCellAt(u,dir,i); if(c) arr.push({r:c.r,c:c.c,dir}); } return arr; }\nfunction range_line(u, aimDir){ const dir=aimDir||u.facing; return forwardLineAt(u,dir).map(p=>({r:p.r,c:p.c,dir})); }\nfunction inRadiusCells(u, maxManhattan, {allowOccupied=false, includeSelf=true}={}){\n  const res=[];\n  for(let r=1;r<=ROWS;r++){\n    for(let c=1;c<=COLS;c++){\n      if(!clampCell(r,c)) continue;\n      const occ = getUnitAt(r,c);\n      const isSelf = unitCoversCell(u, r, c);\n      if(mdist(u,{r,c})<=maxManhattan){\n        if(!allowOccupied && occ && !(includeSelf && isSelf)) continue;\n        res.push({r,c});\n      }\n    }\n  }\n  return res;\n}\nfunction range_move_radius(u, radius){\n  return inRadiusCells(u, radius, {allowOccupied:false, includeSelf:true})\n    .map(p=>({r:p.r,c:p.c,dir:cardinalDirFromDelta(p.r-u.r,p.c-u.c)}));\n}\nfunction range_square_n(u, nHalf){\n  const arr=[];\n  for(let dr=-nHalf; dr<=nHalf; dr++){\n    for(let dc=-nHalf; dc<=nHalf; dc++){\n      const r=u.r+dr, c=u.c+dc; if(clampCell(r,c)) arr.push({r,c,dir:u.facing});\n    }\n  }\n  return arr;\n}\nfunction unitCoversCell(u, r, c){\n  if(!u || u.hp<=0) return false;\n  if(u.size===2) return (r===u.r || r===u.r+1) && (c===u.c || c===u.c+1);\n  return (u.r===r && u.c===c);\n}\nfunction getUnitAt(r,c){\n  for(const id in units){ const u=units[id]; if(!u || u.hp<=0) continue; if(unitCoversCell(u, r, c)) return u; }\n  return null;\n}\nfunction canPlace2x2(u, r, c){\n  const cells=[{r,c},{r:r+1,c},{r,c:c+1},{r:r+1,c:c+1}];\n  for(const p of cells){\n    if(!clampCell(p.r,p.c)) return false;\n    const occ=getUnitAt(p.r,p.c); if(occ && occ!==u) return false;\n  }\n  return true;\n}\n// 横斩区域（横向宽度 x 前向深度）\nfunction forwardRectCentered(u, dir, lateralWidth, depth){\n  const res=[];\n  const d = DIRS[dir];\n  const lat = (dir===\'up\'||dir===\'down\') ? {dr:0,dc:1} : {dr:1,dc:0};\n  const half = Math.floor(lateralWidth/2);\n  for(let step=1; step<=depth; step++){\n    for(let w=-half; w<=half; w++){\n      const rr = u.r + d.dr*step + lat.dr*w;\n      const cc = u.c + d.dc*step + lat.dc*w;\n      if(clampCell(rr,cc)) res.push({r:rr,c:cc,dir});\n    }\n  }\n  return res;\n}\n\n// —— 日志/FX & UI 样式 ——\nfunction appendLog(txt){\n  try{\n    if(!logEl) logEl=document.getElementById(\'log\');\n    if(logEl){ const line=document.createElement(\'div\'); line.textContent=txt; logEl.prepend(line); }\n    else console.log(\'[LOG]\',txt);\n  } catch(e){ console.log(\'[LOG]\',txt); }\n}\nfunction injectFXStyles(){\n  if(document.getElementById(\'fx-styles\')) return;\n  const css = `\n  :root { --fx-z: 1000; --cell: ${CELL_SIZE}px; }\n  #battleArea { position: relative; display: grid; gap: 2px; background: #0d1117; padding: 6px; border-radius: 10px; }\n  .cell { width: var(--cell); height: var(--cell); position: relative; background: #1f1f1f; border-radius: 6px; overflow: hidden; }\n  .cell.void { background: repeating-linear-gradient(45deg, #111 0 6px, #0b0b0b 6px 12px); opacity: 0.5; }\n  .cell.cover { background: #1e293b; box-shadow: inset 0 0 0 2px rgba(59,130,246,0.35); }\n  .cell .coord { position: absolute; right: 4px; bottom: 2px; font-size: 10px; color: rgba(255,255,255,0.35); }\n  .unit { position: absolute; inset: 4px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; color: #fff; font-size: 12px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }\n  .unit.player { background: rgba(82,196,26,0.15); border-color: rgba(82,196,26,0.35); }\n  .unit.enemy  { background: rgba(245,34,45,0.12); border-color: rgba(245,34,45,0.35); }\n  .hpbar,.spbar { width: 90%; height: 6px; background: rgba(255,255,255,0.08); border-radius: 4px; margin-top: 4px; overflow: hidden; }\n  .hpbar .hpfill { height: 100%; background: #ff4d4f; }\n  .spbar .spfill { height: 100%; background: #40a9ff; }\n\n  .fx-layer { position: absolute; inset: 0; pointer-events: none; z-index: var(--fx-z); }\n  .fx { position: absolute; will-change: transform, opacity; --fx-offset-x: 0px; --fx-offset-y: -28px; }\n  .fx-pop { animation: fx-pop 280ms ease-out forwards; }\n  .fx-float { animation: fx-float-up 900ms ease-out forwards; }\n  .fx-impact { width: 60px; height: 60px; background: radial-gradient(closest-side, rgba(255,255,255,0.9), rgba(255,180,0,0.5) 60%, transparent 70%); border-radius: 50%;\n               animation: fx-impact 380ms ease-out forwards; mix-blend-mode: screen; }\n  .fx-number { font-weight: 800; font-size: 18px; text-shadow: 0 1px 0 #000, 0 0 8px rgba(0,0,0,0.35); }\n  .fx-number.hp.damage { color: #ff4d4f; }\n  .fx-number.hp.heal { color: #73d13d; }\n  .fx-number.sp.damage { color: #9254de; }\n  .fx-number.sp.heal { color: #40a9ff; }\n  .fx-number.status { font-size: 16px; letter-spacing: 0.4px; }\n  .fx-number.status.buff { color: #fa8c16; }\n  .fx-number.status.debuff { color: #a8071a; }\n  .fx-attack { width: 150px; height: 150px; position: absolute; transform: translate(-50%, -50%); pointer-events: none;\n               filter: drop-shadow(0 10px 24px rgba(0,0,0,0.55)); mix-blend-mode: screen;\n               --attack-scale: 1; animation: fx-attack-fade 520ms ease-out forwards; }\n  .fx-attack.heavy { --attack-scale: 1.25; animation-duration: 640ms; }\n  .fx-attack.true-damage { mix-blend-mode: lighten; }\n  .fx-attack .flash { position: absolute; left: 50%; top: 50%; width: 68%; height: 68%;\n                      background: radial-gradient(circle, rgba(255,244,214,0.95) 0%, rgba(255,161,22,0.65) 60%, rgba(255,101,9,0) 100%);\n                      border-radius: 50%; transform: translate(-50%, -50%) scale(0.45);\n                      animation: fx-attack-flash 420ms ease-out forwards; }\n  .fx-attack.true-damage .flash { background: radial-gradient(circle, rgba(245,235,255,0.95) 0%, rgba(166,93,255,0.7) 55%, rgba(116,55,255,0) 100%); }\n  .fx-attack .slash { position: absolute; left: 50%; top: 50%; width: 22px; height: 120%; border-radius: 999px;\n                      background: linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.9) 35%, rgba(255,128,17,0.9) 68%, rgba(255,255,255,0) 100%);\n                      opacity: 0; transform-origin: 50% 100%; }\n  .fx-attack.true-damage .slash { background: linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.92) 35%, rgba(145,102,255,0.94) 68%, rgba(255,255,255,0) 100%); }\n  .fx-attack .slash.main { animation: fx-attack-slash 420ms ease-out forwards; }\n  .fx-attack .slash.reverse { animation: fx-attack-slash-rev 420ms ease-out forwards; }\n  .fx-attack .ring { position: absolute; left: 50%; top: 50%; width: 56%; height: 56%; border-radius: 50%; border: 3px solid rgba(255,198,73,0.95);\n                     transform: translate(-50%, -50%) scale(0.4); opacity: 0; box-shadow: 0 0 22px rgba(255,157,46,0.45);\n                     animation: fx-attack-ring 520ms ease-out forwards; }\n  .fx-attack.true-damage .ring { border-color: rgba(155,110,255,0.95); box-shadow: 0 0 26px rgba(155,110,255,0.55); }\n  .fx-attack .spark { position: absolute; left: 50%; top: 50%; width: 14px; height: 14px; border-radius: 50%;\n                      background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0) 65%);\n                      opacity: 0; transform-origin: 0 0; --spark-angle: 0deg;\n                      animation: fx-attack-spark 480ms ease-out forwards; }\n  .fx-attack.true-damage .spark { background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(166,93,255,0) 65%); }\n  .fx-attack .spark.left { --spark-angle: -40deg; }\n  .fx-attack .spark.right { --spark-angle: 140deg; }\n  .skill-fx { position: absolute; transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: screen; opacity: 0;\n              filter: drop-shadow(0 12px 26px rgba(0,0,0,0.55)); animation: skill-fx-fade 680ms ease-out forwards; }\n  .skill-fx .glyph { font-weight: 800; font-size: 26px; letter-spacing: 1px; color: var(--skill-outline, rgba(255,255,255,0.85));\n                     text-shadow: 0 0 12px rgba(255,255,255,0.35); }\n  .skill-fx.slash { width: 160px; height: 160px; }\n  .skill-fx.slash .flash { position: absolute; left: 50%; top: 50%; width: 62%; height: 62%; border-radius: 50%; opacity: 0;\n                            background: radial-gradient(circle, var(--skill-secondary, rgba(255,255,255,0.8)) 0%, rgba(255,255,255,0) 70%);\n                            transform: translate(-50%, -50%) scale(0.4); animation: skill-slash-flash 420ms ease-out forwards; }\n  .skill-fx.slash .ring { position: absolute; left: 50%; top: 50%; width: 56%; height: 56%; border-radius: 50%;\n                          border: 3px solid var(--skill-secondary, rgba(255,255,255,0.65)); opacity: 0;\n                          transform: translate(-50%, -50%) scale(0.35);\n                          box-shadow: 0 0 18px var(--skill-secondary, rgba(255,255,255,0.35)); animation: skill-slash-ring 520ms ease-out forwards; }\n  .skill-fx.slash .sparks { position: absolute; inset: 0; }\n  .skill-fx.slash .spark { position: absolute; left: 50%; top: 50%; width: 16px; height: 16px; border-radius: 50%; opacity: 0;\n                           background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0) 70%);\n                           transform-origin: 0 0; animation: skill-slash-spark 480ms ease-out forwards; }\n  .skill-fx.slash .spark.left { --spark-angle: -50deg; }\n  .skill-fx.slash .spark.right { --spark-angle: 140deg; }\n  .skill-fx.slash .strokes { position: absolute; inset: 0; }\n  .skill-fx.slash .stroke { position: absolute; left: 50%; top: 50%; width: 26px; height: 120%; border-radius: 999px; opacity: 0;\n                            transform-origin: 50% 100%; background: linear-gradient(180deg, rgba(255,255,255,0), var(--skill-primary, rgba(255,255,255,0.92)) 45%, rgba(255,255,255,0));\n                            animation: skill-slash-stroke 520ms ease-out forwards; }\n  .skill-fx.slash .stroke[data-index="0"] { --stroke-offset: -18deg; --stroke-shift: -6deg; }\n  .skill-fx.slash .stroke[data-index="1"] { --stroke-offset: 0deg; --stroke-shift: 0deg; animation-delay: 40ms; }\n  .skill-fx.slash .stroke[data-index="2"] { --stroke-offset: 20deg; --stroke-shift: 8deg; animation-delay: 70ms; }\n  .skill-fx.claw { width: 160px; height: 160px; }\n  .skill-fx.claw .burst { position: absolute; left:50%; top:50%; width: 68%; height:68%; border-radius: 50%; opacity:0.8;\n                           transform: translate(-50%,-50%) scale(0.4);\n                           background: radial-gradient(circle, var(--skill-secondary, rgba(255,255,255,0.7)) 0%, rgba(255,255,255,0) 70%);\n                           animation: skill-claw-burst 520ms ease-out forwards; }\n  .skill-fx.claw[data-variant="mecha"] .burst { box-shadow: 0 0 22px var(--skill-primary, rgba(255,255,255,0.6));\n                                                 background: radial-gradient(circle, rgba(255,255,255,0.65) 0%, var(--skill-secondary, rgba(255,255,255,0.0)) 70%); }\n  .skill-fx.claw .scratch { position:absolute; left:50%; top:50%; width:12px; height:120%; opacity:0; transform-origin:50% 0;\n                             animation: skill-claw-scratch 560ms ease-out forwards; }\n  .skill-fx.claw .scratch span { display:block; width:100%; height:100%; border-radius:999px;\n                                 background: linear-gradient(180deg, rgba(255,255,255,0.05), var(--skill-primary,#ffffff) 55%, rgba(255,255,255,0));\n                                 box-shadow: 0 0 16px var(--skill-primary, rgba(255,255,255,0.35)); }\n  .skill-fx.claw .shard { position:absolute; left:50%; top:50%; width:18px; height:38px; border-radius:999px; opacity:0;\n                          transform-origin:50% 90%; background: linear-gradient(180deg, rgba(255,255,255,0.3), var(--skill-primary, rgba(255,255,255,0.9)) 60%, rgba(255,255,255,0));\n                          filter: drop-shadow(0 0 10px rgba(255,255,255,0.45)); animation: skill-claw-shard 520ms ease-out forwards; }\n  .skill-fx.claw[data-variant="mecha"] .servo-ring { position:absolute; left:50%; top:50%; width:130%; height:130%; border-radius:50%;\n                                                       border:3px solid var(--skill-primary, rgba(255,255,255,0.85)); opacity:0;\n                                                       transform: translate(-50%, -50%) scale(0.4);\n                                                       box-shadow: 0 0 18px var(--skill-secondary, rgba(255,255,255,0.35));\n                                                       animation: skill-claw-servo 620ms ease-out forwards; }\n  .skill-fx.claw[data-variant="mecha"] .servo-flare { position:absolute; left:50%; top:50%; width:84%; height:84%; border-radius:50%; opacity:0;\n                                                        transform: translate(-50%, -50%) scale(0.5);\n                                                        background: radial-gradient(circle, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0) 70%);\n                                                        animation: skill-claw-servo-flare 600ms ease-out forwards; }\n  .skill-fx.claw[data-variant="mecha"] .mecha-sparks { position:absolute; inset:0; }\n  .skill-fx.claw[data-variant="mecha"] .mecha-sparks .spark { position:absolute; left:50%; top:50%; width:18px; height:18px; border-radius:50%;\n                                                                background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0) 70%);\n                                                                opacity:0; transform-origin:0 0; animation: skill-claw-mecha-spark 520ms ease-out forwards; }\n  .skill-fx.claw[data-variant="mecha"] .mecha-sparks .spark.one { --spark-angle: -35deg; }\n  .skill-fx.claw[data-variant="mecha"] .mecha-sparks .spark.two { --spark-angle: 145deg; animation-delay: 70ms; }\n  .skill-fx.claw .scratch[data-index="0"] { --scratch-shift:-28px; }\n  .skill-fx.claw .scratch[data-index="1"] { --scratch-shift:-12px; animation-delay: 30ms; }\n  .skill-fx.claw .scratch[data-index="2"] { --scratch-shift: 6px; animation-delay: 60ms; }\n  .skill-fx.claw .scratch[data-index="3"] { --scratch-shift: 22px; animation-delay: 90ms; }\n  .skill-fx.claw .scratch[data-index="4"] { --scratch-shift: 38px; animation-delay: 120ms; }\n  .skill-fx.attack-swing { width: 150px; height: 150px; }\n  .skill-fx.attack-swing .glow { position:absolute; left:50%; top:50%; width:82%; height:82%; border-radius:50%; opacity:0;\n                                 transform: translate(-50%, -50%) scale(0.3);\n                                 background: radial-gradient(circle, var(--skill-secondary, rgba(255,255,255,0.6)) 0%, rgba(255,255,255,0) 70%);\n                                 animation: attack-swing-glow 420ms ease-out forwards; }\n  .skill-fx.attack-swing .arc { position:absolute; left:50%; top:50%; width:18px; height:94%; border-radius:999px; opacity:0;\n                                transform-origin:50% 88%;\n                                background: linear-gradient(180deg, rgba(255,255,255,0.0), var(--skill-primary, rgba(255,255,255,0.95)) 52%, rgba(255,255,255,0));\n                                box-shadow: 0 0 18px var(--skill-primary, rgba(255,255,255,0.4));\n                                animation: attack-swing-arc 420ms ease-out forwards; }\n  .skill-fx.attack-swing[data-variant="claw"] .arc { height: 100%; width: 16px; transform-origin:50% 90%; }\n  .skill-fx.attack-swing[data-variant="mecha"] .arc { box-shadow: 0 0 22px var(--skill-primary, rgba(255,255,255,0.55)); }\n  .skill-fx.attack-swing[data-variant="wide"] .arc { height: 110%; }\n  .skill-fx.attack-swing .arc { transform: translate(-50%, -50%) rotate(calc(var(--attack-angle, 0deg) + var(--arc-angle-offset, 0deg))); }\n  .skill-fx.attack-muzzle { width: calc(var(--attack-length, 90px) + 50px); height: 86px;\n                            transform: translate(-50%, -50%) rotate(var(--attack-angle, 0deg)); }\n  .skill-fx.attack-muzzle .flash { position:absolute; left:24%; top:50%; width:48px; height:48px; border-radius:50%; opacity:0.9;\n                                   transform: translate(-50%, -50%) scale(0.4);\n                                   background: radial-gradient(circle, var(--skill-primary, rgba(255,255,255,0.85)) 0%, rgba(255,255,255,0) 72%);\n                                   box-shadow: 0 0 24px var(--skill-primary, rgba(255,255,255,0.55));\n                                   animation: attack-muzzle-flash 360ms ease-out forwards; }\n  .skill-fx.attack-muzzle .trail { position:absolute; left:50%; top:50%; height:12px; width: var(--attack-length, 90px);\n                                   border-radius: 999px; opacity:0;\n                                   transform: translate(-10%, -50%);\n                                   background: linear-gradient(90deg, rgba(255,255,255,0.0) 0%, var(--skill-primary, rgba(255,255,255,0.85)) 45%, rgba(255,255,255,0) 100%);\n                                   box-shadow: 0 0 18px var(--skill-secondary, rgba(255,255,255,0.4));\n                                   animation: attack-muzzle-trail 420ms ease-out forwards; }\n  .skill-fx.attack-aura { width: 150px; height: 150px; }\n  .skill-fx.attack-aura .ring { position:absolute; left:50%; top:50%; width:86%; height:86%; border-radius:50%; opacity:0;\n                                 transform: translate(-50%, -50%) scale(0.35);\n                                 border:2px solid var(--skill-primary, rgba(255,255,255,0.8));\n                                 box-shadow: 0 0 18px var(--skill-secondary, rgba(255,255,255,0.35));\n                                 animation: attack-aura-ring 520ms ease-out forwards; }\n  .skill-fx.attack-aura .pulse { position:absolute; left:50%; top:50%; width:64%; height:64%; border-radius:50%; opacity:0;\n                                 transform: translate(-50%, -50%) scale(0.5);\n                                 background: radial-gradient(circle, var(--skill-secondary, rgba(255,255,255,0.55)) 0%, rgba(255,255,255,0) 72%);\n                                 animation: attack-aura-pulse 520ms ease-out forwards; }\n  .skill-fx.beam { width: calc(var(--skill-length, 140px) + 60px); height: 80px; }\n  .skill-fx.beam .muzzle { position:absolute; left:50%; top:50%; width:52px; height:52px; border-radius:50%; opacity:0.8;\n                           transform: translate(-50%,-50%) scale(0.35);\n                           background: radial-gradient(circle, var(--skill-secondary, rgba(255,255,255,0.85)) 0%, rgba(255,255,255,0) 70%);\n                           animation: skill-beam-muzzle 360ms ease-out forwards; }\n  .skill-fx.beam .trail { position:absolute; left:50%; top:50%; height:12px; width: var(--skill-length, 140px);\n                          background: linear-gradient(90deg, var(--skill-secondary, rgba(255,255,255,0.45)) 0%, var(--skill-primary, rgba(255,255,255,0.95)) 70%, rgba(255,255,255,0) 100%);\n                          border-radius: 999px; opacity:0; transform-origin:0 50%; animation: skill-beam-trail 360ms ease-out forwards; }\n  .skill-fx.beam .flare { position:absolute; right:8%; top:50%; width:42px; height:42px; border-radius:50%; opacity:0;\n                          background: radial-gradient(circle, rgba(255,255,255,0.85) 0%, transparent 70%);\n                          animation: skill-beam-flare 380ms ease-out forwards; }\n  .skill-fx.burst { width: 200px; height: 200px; }\n  .skill-fx.burst .ring { position:absolute; left:50%; top:50%; width:70%; height:70%; border-radius:50%; border:3px solid var(--skill-primary,#ffffff);\n                          transform:translate(-50%,-50%) scale(0.4); opacity:0; animation: skill-burst-ring 620ms ease-out forwards; }\n  .skill-fx.burst .wave { position:absolute; left:50%; top:50%; width:96%; height:96%; border-radius:50%; opacity:0;\n                          background: radial-gradient(circle, var(--skill-secondary, rgba(255,255,255,0.6)) 0%, rgba(255,255,255,0) 80%);\n                          transform:translate(-50%,-50%) scale(0.3); animation: skill-burst-wave 660ms ease-out forwards; }\n  .skill-fx.burst .core { position:absolute; left:50%; top:50%; width:38%; height:38%; border-radius:50%; opacity:0.9;\n                          transform:translate(-50%,-50%); background: radial-gradient(circle, rgba(255,255,255,0.92) 0%, var(--skill-primary, rgba(255,255,255,0.85)) 80%);\n                          animation: skill-burst-core 420ms ease-out forwards; }\n  .skill-fx.aura { width: 170px; height: 170px; filter: drop-shadow(0 0 16px var(--skill-primary, rgba(255,255,255,0.35))); }\n  .skill-fx.aura .halo { position:absolute; left:50%; top:50%; width:86%; height:86%; border-radius:50%; opacity:0;\n                          transform:translate(-50%,-50%) scale(0.6);\n                          background: radial-gradient(circle, var(--skill-secondary, rgba(255,255,255,0.75)) 0%, rgba(255,255,255,0) 75%);\n                          animation: skill-aura-halo 760ms ease-out forwards; }\n  .skill-fx.aura .glyph { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); opacity:0;\n                          animation: skill-aura-glyph 720ms ease-out forwards; }\n  .skill-fx.aura .particles { position:absolute; inset:0; background: radial-gradient(circle, var(--skill-primary, rgba(255,255,255,0.35)) 0%, rgba(255,255,255,0) 70%);\n                              border-radius:50%; opacity:0.6; filter: blur(12px); animation: skill-aura-pulse 780ms ease-out forwards; }\n  .skill-fx.lightning { width: 180px; height: 180px; }\n  .skill-fx.lightning .glow { position:absolute; left:50%; top:50%; width:80%; height:80%; border-radius:50%; opacity:0.8;\n                               transform:translate(-50%,-50%) scale(0.4); background: radial-gradient(circle, var(--skill-secondary, rgba(255,255,255,0.85)) 0%, rgba(255,255,255,0) 75%);\n                               animation: skill-lightning-glow 520ms ease-out forwards; }\n  .skill-fx.lightning .bolt { position:absolute; left:50%; top:50%; width:6px; height:110%; opacity:0;\n                              background: linear-gradient(180deg, rgba(255,255,255,0), var(--skill-primary,#ffffff) 45%, rgba(255,255,255,0));\n                              transform-origin:50% 0; animation: skill-lightning-bolt 520ms ease-out forwards; }\n  .skill-fx.lightning .bolt[data-index="0"] { transform: translate(-50%, -50%) rotate(calc(var(--skill-angle,0deg) - 18deg)); }\n  .skill-fx.lightning .bolt[data-index="1"] { transform: translate(-50%, -50%) rotate(calc(var(--skill-angle,0deg) + 6deg)); animation-delay: 50ms; }\n  .skill-fx.lightning .bolt[data-index="2"] { transform: translate(-50%, -50%) rotate(calc(var(--skill-angle,0deg) + 28deg)); animation-delay: 90ms; }\n  .skill-fx.lightning .bolt[data-index="3"] { transform: translate(-50%, -50%) rotate(calc(var(--skill-angle,0deg) - 40deg)); animation-delay: 120ms; }\n  .skill-fx.rune { width: 190px; height: 190px; }\n  .skill-fx.rune .sigil { position:absolute; left:50%; top:50%; width:74%; height:74%; border-radius:50%; border:2px solid var(--skill-primary,#ffffff);\n                          transform:translate(-50%,-50%) scale(0.4); opacity:0; animation: skill-rune-circle 700ms ease-out forwards; }\n  .skill-fx.rune .orbit { position:absolute; left:50%; top:50%; width:90%; height:90%; border-radius:50%; border:1px dashed var(--skill-secondary,#ffffff);\n                          transform:translate(-50%,-50%); opacity:0.65; animation: skill-rune-spin 900ms linear forwards; }\n  .skill-fx.rune .flare { position:absolute; left:50%; top:50%; width:44%; height:44%; border-radius:50%; opacity:0;\n                          background: radial-gradient(circle, rgba(255,255,255,0.92) 0%, var(--skill-primary, rgba(255,255,255,0.82)) 80%);\n                          transform:translate(-50%,-50%); animation: skill-rune-flare 520ms ease-out forwards; }\n  .skill-fx.impact { width: 180px; height: 180px; }\n  .skill-fx.impact .shock { position:absolute; left:50%; top:50%; width:70%; height:70%; border-radius:50%; opacity:0;\n                             background: radial-gradient(circle, var(--skill-primary, rgba(255,255,255,0.75)) 0%, rgba(255,255,255,0) 80%);\n                             transform:translate(-50%,-50%) scale(0.45); animation: skill-impact-shock 640ms ease-out forwards; }\n  .skill-fx.impact .dust { position:absolute; left:50%; top:65%; width:120%; height:40%; opacity:0.7;\n                           background: radial-gradient(circle, var(--skill-secondary, rgba(255,255,255,0.6)) 0%, rgba(255,255,255,0) 80%);\n                           transform:translate(-50%,-50%) scaleX(0.4); animation: skill-impact-dust 720ms ease-out forwards; filter: blur(6px); }\n  .skill-fx.impact .cracks { position:absolute; left:50%; top:50%; width:80%; height:80%; opacity:0;\n                             background: radial-gradient(circle, rgba(255,255,255,0.75) 0%, rgba(255,255,255,0) 75%);\n                             transform:translate(-50%,-50%) scale(0.3); mask: radial-gradient(circle, transparent 45%, #000 46%);\n                             animation: skill-impact-crack 620ms ease-out forwards; }\n  .skill-fx.cascade { width: 130px; height: 200px; }\n  .skill-fx.cascade .column { position:absolute; left:50%; top:0; width:46px; height:100%; opacity:0.75;\n                               background: linear-gradient(180deg, var(--skill-primary, rgba(255,255,255,0.7)) 0%, rgba(255,255,255,0) 85%);\n                               transform:translateX(-50%); animation: skill-cascade-column 720ms ease-out forwards; }\n  .skill-fx.cascade .drop { position:absolute; left:50%; width:14px; height:24px; border-radius:999px;\n                             background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, var(--skill-secondary, rgba(255,255,255,0.65)) 70%);\n                             opacity:0; animation: skill-cascade-drop 680ms ease-out forwards; }\n  .skill-fx.cascade .drop[data-index="0"] { top:10%; animation-delay: 20ms; }\n  .skill-fx.cascade .drop[data-index="1"] { top:32%; animation-delay: 70ms; }\n  .skill-fx.cascade .drop[data-index="2"] { top:56%; animation-delay: 110ms; }\n  .skill-fx.cascade .drop[data-index="3"] { top:74%; animation-delay: 150ms; }\n  .skill-fx.cascade .drop[data-index="4"] { top:20%; animation-delay: 200ms; }\n  .skill-fx.cascade .drop[data-index="5"] { top:44%; animation-delay: 240ms; }\n  .skill-fx.spiral { width: 180px; height: 180px; }\n  .skill-fx.spiral .swirl { position:absolute; left:50%; top:50%; width:80%; height:80%; border-radius:50%; border:4px solid var(--skill-primary, rgba(255,255,255,0.7));\n                             transform:translate(-50%,-50%) scale(0.3); opacity:0; animation: skill-spiral-spin 640ms ease-out forwards; }\n  .skill-fx.spiral .swirl.two { border-color: var(--skill-secondary, rgba(255,255,255,0.7)); animation-delay: 80ms; }\n  .skill-fx.spiral .center { position:absolute; left:50%; top:50%; width:32%; height:32%; border-radius:50%; opacity:0.9;\n                              background: radial-gradient(circle, rgba(255,255,255,0.92) 0%, var(--skill-secondary, rgba(255,255,255,0.75)) 90%);\n                              transform:translate(-50%,-50%); animation: skill-spiral-center 540ms ease-out forwards; }\n  .fx-death { position: absolute; transform: translate(-50%, -50%); pointer-events: none; overflow: visible;\n              filter: drop-shadow(0 14px 28px rgba(0,0,0,0.45)); animation: fx-death-fade 900ms ease-out forwards; }\n  .fx-death .piece { position: absolute; left: 0; width: 100%; height: 50%; box-sizing: border-box; border-radius: 8px;\n                     background: rgba(255,255,255,0.14); border: 1px solid rgba(255,255,255,0.28); }\n  .fx-death.player .piece { background: rgba(91,140,255,0.18); border-color: rgba(91,140,255,0.45); }\n  .fx-death.enemy  .piece { background: rgba(255,77,79,0.18); border-color: rgba(255,77,79,0.45); }\n  .fx-death .piece.top { top: 0; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;\n                         animation: fx-death-top 900ms ease-out forwards; }\n  .fx-death .piece.bottom { bottom: 0; border-top-left-radius: 4px; border-top-right-radius: 4px;\n                            animation: fx-death-bottom 900ms ease-out forwards; }\n  .fx-death.size-2 .piece { border-radius: 12px; }\n  .fx-death .crack { position: absolute; left: 50%; top: 0; width: 3px; height: 100%;\n                     background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0));\n                     transform: translateX(-50%) scaleY(0); mix-blend-mode: screen;\n                     animation: fx-death-crack 260ms ease-out forwards, fx-death-fade 900ms ease-out forwards; }\n  .fx-death .dust { position: absolute; left: 50%; top: 50%; width: 100%; height: 100%;\n                    background: radial-gradient(circle, rgba(255,255,255,0.28) 0%, rgba(255,255,255,0) 70%);\n                    transform: translate(-50%, -50%) scale(0.65); opacity: 0.85;\n                    animation: fx-death-dust 900ms ease-out forwards; pointer-events: none; }\n  .fx-trail { width: 6px; height: 0; background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,0.85), rgba(255,255,255,0));\n              box-shadow: 0 0 8px rgba(255,255,255,0.8); transform-origin: 0 0; animation: fx-trail 220ms linear forwards; mix-blend-mode: screen; }\n  .shake { animation: cam-shake 180ms ease-in-out 1; }\n  .shake-heavy { animation: cam-shake-heavy 320ms ease-in-out 1; }\n  .pulse { animation: pulse 600ms ease-out 1; }\n  @keyframes fx-pop { 0%{ transform: scale(0.7); opacity: 0.0; } 55%{ transform: scale(1.1); opacity: 1; } 100%{ transform: scale(1); opacity: 1; } }\n  @keyframes fx-float-up { 0%{ transform: translate(-50%,-50%) translate(var(--fx-offset-x), var(--fx-offset-y)); opacity: 1; }\n                           100%{ transform: translate(-50%,-50%) translate(var(--fx-offset-x), calc(var(--fx-offset-y) - 36px)); opacity: 0; } }\n  @keyframes fx-attack-fade { 0% { opacity: 0; transform: translate(-50%, -50%) scale(calc(var(--attack-scale, 1) * 0.75)); }\n                               35% { opacity: 1; transform: translate(-50%, -50%) scale(calc(var(--attack-scale, 1) * 1.06)); }\n                               100% { opacity: 0; transform: translate(-50%, -50%) scale(calc(var(--attack-scale, 1) * 0.92)); } }\n  @keyframes fx-attack-flash { 0% { opacity: 0; transform: translate(-50%, -50%) scale(calc(var(--attack-scale, 1) * 0.35)); }\n                               20% { opacity: 1; transform: translate(-50%, -50%) scale(calc(var(--attack-scale, 1) * 1.05)); }\n                               100% { opacity: 0; transform: translate(-50%, -50%) scale(calc(var(--attack-scale, 1) * 0.8)); } }\n  @keyframes fx-attack-slash { 0% { opacity: 0; transform: translate(-50%, -50%) rotate(calc(var(--fx-angle, 0deg) - 26deg)) scaleY(0.1) scaleX(0.6); }\n                               35% { opacity: 1; transform: translate(-50%, -50%) rotate(calc(var(--fx-angle, 0deg) - 6deg)) scaleY(1.2) scaleX(1); }\n                               100% { opacity: 0; transform: translate(-50%, -50%) rotate(calc(var(--fx-angle, 0deg) + 14deg)) scaleY(0.4) scaleX(0.85); } }\n  @keyframes fx-attack-slash-rev { 0% { opacity: 0; transform: translate(-50%, -50%) rotate(calc(var(--fx-angle, 0deg) + 154deg)) scaleY(0.1) scaleX(0.5); }\n                                   35% { opacity: 1; transform: translate(-50%, -50%) rotate(calc(var(--fx-angle, 0deg) + 174deg)) scaleY(1.1) scaleX(0.95); }\n                                   100% { opacity: 0; transform: translate(-50%, -50%) rotate(calc(var(--fx-angle, 0deg) + 198deg)) scaleY(0.35) scaleX(0.8); } }\n  @keyframes fx-attack-ring { 0% { opacity: 0; transform: translate(-50%, -50%) scale(calc(var(--attack-scale, 1) * 0.3)); }\n                              30% { opacity: 1; transform: translate(-50%, -50%) scale(calc(var(--attack-scale, 1) * 1.05)); }\n                              100% { opacity: 0; transform: translate(-50%, -50%) scale(calc(var(--attack-scale, 1) * 1.45)); } }\n  @keyframes fx-attack-spark { 0% { opacity: 0; transform: translate(-50%, -50%) rotate(var(--spark-angle, 0deg)) translateX(0) scale(0.3); }\n                               35% { opacity: 1; }\n                               100% { opacity: 0; transform: translate(-50%, -50%) rotate(var(--spark-angle, 0deg)) translateX(86px) scale(0.65); } }\n  @keyframes attack-swing-glow { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.25); }\n                                 35% { opacity: 0.85; transform: translate(-50%, -50%) scale(0.95); }\n                                 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.3); } }\n  @keyframes attack-swing-arc { 0% { opacity: 0; transform: translate(-50%, -50%) rotate(calc(var(--attack-angle,0deg) + var(--arc-angle-offset,0deg) - 26deg)) scaleY(0.25) scaleX(0.55); }\n                                35% { opacity: 1; transform: translate(-50%, -50%) rotate(calc(var(--attack-angle,0deg) + var(--arc-angle-offset,0deg) - 6deg)) scaleY(1.15) scaleX(1.05); }\n                                100% { opacity: 0; transform: translate(-50%, -50%) rotate(calc(var(--attack-angle,0deg) + var(--arc-angle-offset,0deg) + 16deg)) scaleY(0.45) scaleX(0.8); } }\n  @keyframes attack-muzzle-flash { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.35); }\n                                   30% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }\n                                   100% { opacity: 0; transform: translate(-50%, -50%) scale(1.35); } }\n  @keyframes attack-muzzle-trail { 0% { opacity: 0; width: 0; }\n                                   35% { opacity: 1; width: var(--attack-length, 90px); }\n                                   100% { opacity: 0; width: var(--attack-length, 90px); } }\n  @keyframes attack-aura-ring { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.35); }\n                                40% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }\n                                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.45); } }\n  @keyframes attack-aura-pulse { 0% { opacity: 0.7; transform: translate(-50%, -50%) scale(0.6); }\n                                 55% { opacity: 0.95; transform: translate(-50%, -50%) scale(1.0); }\n                                 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.3); } }\n  @keyframes skill-fx-fade { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.82); }\n                             22% { opacity: 1; }\n                             100% { opacity: 0; transform: translate(-50%, -50%) scale(1.08); } }\n  @keyframes skill-slash-flash { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.4); }\n                                 35% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }\n                                 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.3); } }\n  @keyframes skill-slash-ring { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.35); }\n                                40% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }\n                                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.45); } }\n  @keyframes skill-slash-spark { 0% { opacity: 0; transform: translate(-50%, -50%) rotate(var(--spark-angle, 0deg)) translateX(0) scale(0.4); }\n                                 35% { opacity: 1; }\n                                 100% { opacity: 0; transform: translate(-50%, -50%) rotate(var(--spark-angle, 0deg)) translateX(90px) scale(0.7); } }\n  @keyframes skill-slash-stroke { 0% { opacity: 0; transform: translate(-50%, -50%) rotate(calc(var(--skill-angle,0deg) + var(--stroke-offset,0deg))) scaleY(0.2) scaleX(0.6); }\n                                  35% { opacity: 1; transform: translate(-50%, -50%) rotate(calc(var(--skill-angle,0deg) + var(--stroke-offset,0deg) + var(--stroke-shift,0deg))) scaleY(1.25) scaleX(1.05); }\n                                  100% { opacity: 0; transform: translate(-50%, -50%) rotate(calc(var(--skill-angle,0deg) + var(--stroke-offset,0deg) + 22deg)) scaleY(0.35) scaleX(0.8); } }\n  @keyframes skill-claw-burst { 0% { opacity: 0.65; transform: translate(-50%, -50%) scale(0.35); }\n                                60% { opacity: 0.9; transform: translate(-50%, -50%) scale(1.05); }\n                                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.4); } }\n  @keyframes skill-claw-scratch { 0% { opacity: 0; transform: translate(calc(-50% + var(--scratch-shift,0px)), -60%) scaleY(0.3); }\n                                   40% { opacity: 1; transform: translate(calc(-50% + var(--scratch-shift,0px)), 10%) scaleY(1.05); }\n                                   100% { opacity: 0; transform: translate(calc(-50% + var(--scratch-shift,0px)), 60%) scaleY(0.4); } }\n  @keyframes skill-claw-shard { 0% { opacity: 0; transform: translate(calc(-50% + var(--shard-drift,0px)), -30%) rotate(calc(var(--shard-rotate,0deg) - 24deg)) scale(0.45); }\n                                 45% { opacity: 1; transform: translate(calc(-50% + var(--shard-drift,0px)), 18%) rotate(calc(var(--shard-rotate,0deg))) scale(1.05); }\n                                 100% { opacity: 0; transform: translate(calc(-50% + var(--shard-drift,0px)), 70%) rotate(calc(var(--shard-rotate,0deg) + 14deg)) scale(0.6); } }\n  @keyframes skill-claw-servo { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.35) rotate(0deg); }\n                                 35% { opacity: 1; transform: translate(-50%, -50%) scale(1.0) rotate(40deg); }\n                                 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.25) rotate(90deg); } }\n  @keyframes skill-claw-servo-flare { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.6); }\n                                       40% { opacity: 0.85; transform: translate(-50%, -50%) scale(1.0); }\n                                       100% { opacity: 0; transform: translate(-50%, -50%) scale(1.35); } }\n  @keyframes skill-claw-mecha-spark { 0% { opacity: 0; transform: translate(-50%, -50%) rotate(var(--spark-angle, 0deg)) translateX(0) scale(0.4); }\n                                      40% { opacity: 1; }\n                                      100% { opacity: 0; transform: translate(-50%, -50%) rotate(var(--spark-angle, 0deg)) translateX(92px) scale(0.7); } }\n  @keyframes skill-beam-muzzle { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.25); }\n                                 45% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }\n                                 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.25); } }\n  @keyframes skill-beam-trail { 0% { opacity: 0; width: 0; }\n                                30% { opacity: 1; width: var(--skill-length, 140px); }\n                                100% { opacity: 0; width: var(--skill-length, 140px); } }\n  @keyframes skill-beam-flare { 0% { opacity: 0; transform: translateY(-50%) scale(0.4); }\n                                40% { opacity: 0.9; transform: translateY(-50%) scale(1.05); }\n                                100% { opacity: 0; transform: translateY(-50%) scale(1.4); } }\n  @keyframes skill-burst-ring { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }\n                                40% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }\n                                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.6); } }\n  @keyframes skill-burst-wave { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.25); }\n                                45% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.05); }\n                                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); } }\n  @keyframes skill-burst-core { 0% { opacity: 0.2; transform: translate(-50%, -50%) scale(0.8); }\n                                40% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }\n                                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); } }\n  @keyframes skill-aura-halo { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }\n                                35% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }\n                                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.35); } }\n  @keyframes skill-aura-glyph { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.6); }\n                                 35% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }\n                                 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.12); } }\n  @keyframes skill-aura-pulse { 0% { opacity: 0.6; transform: scale(0.75); }\n                                 60% { opacity: 0.8; transform: scale(1.0); }\n                                 100% { opacity: 0; transform: scale(1.35); } }\n  @keyframes skill-lightning-glow { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.35); }\n                                    35% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }\n                                    100% { opacity: 0; transform: translate(-50%, -50%) scale(1.4); } }\n  @keyframes skill-lightning-bolt { 0% { opacity: 0; transform: translate(-50%, -50%) rotate(calc(var(--skill-angle,0deg) - 12deg)) scaleY(0.2); }\n                                   30% { opacity: 1; transform: translate(-50%, -50%) rotate(calc(var(--skill-angle,0deg) - 2deg)) scaleY(1.0); }\n                                   100% { opacity: 0; transform: translate(-50%, -50%) rotate(calc(var(--skill-angle,0deg) + 12deg)) scaleY(0.4); } }\n  @keyframes skill-rune-circle { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.4); }\n                                 35% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }\n                                 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); } }\n  @keyframes skill-rune-spin { 0% { opacity: 0.6; transform: translate(-50%, -50%) rotate(0deg) scale(0.95); }\n                               100% { opacity: 0; transform: translate(-50%, -50%) rotate(220deg) scale(1.05); } }\n  @keyframes skill-rune-flare { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.6); }\n                                40% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }\n                                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); } }\n  @keyframes skill-impact-shock { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.4); }\n                                  40% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }\n                                  100% { opacity: 0; transform: translate(-50%, -50%) scale(1.45); } }\n  @keyframes skill-impact-dust { 0% { opacity: 0; transform: translate(-50%, -50%) scaleX(0.4); }\n                                 40% { opacity: 0.75; transform: translate(-50%, -50%) scaleX(1.0); }\n                                 100% { opacity: 0; transform: translate(-50%, -64%) scaleX(1.3); } }\n  @keyframes skill-impact-crack { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }\n                                  30% { opacity: 0.9; transform: translate(-50%, -50%) scale(0.9); }\n                                  100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); } }\n  @keyframes skill-cascade-column { 0% { opacity: 0; height: 0; }\n                                    30% { opacity: 0.75; height: 100%; }\n                                    100% { opacity: 0; height: 100%; } }\n  @keyframes skill-cascade-drop { 0% { opacity: 0; transform: translate(-50%, -30%) scale(0.6); }\n                                   40% { opacity: 1; transform: translate(-50%, 20%) scale(1.0); }\n                                   100% { opacity: 0; transform: translate(-50%, 80%) scale(0.4); } }\n  @keyframes skill-spiral-spin { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3) rotate(0deg); }\n                                 40% { opacity: 1; transform: translate(-50%, -50%) scale(1.0) rotate(160deg); }\n                                 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2) rotate(320deg); } }\n  @keyframes skill-spiral-center { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }\n                                   40% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }\n                                   100% { opacity: 0; transform: translate(-50%, -50%) scale(1.25); } }\n  @keyframes fx-impact { 0%{ transform: translate(-50%,-50%) scale(0.6); opacity: 0; }\n                         50%{ transform: translate(-50%,-50%) scale(1.1); opacity: 1; }\n                         100%{ transform: translate(-50%,-50%) scale(0.8); opacity: 0; } }\n  @keyframes fx-trail { 0% { opacity: 0; } 30% { opacity: 1; } 100% { opacity: 0; } }\n  @keyframes fx-death-top {\n    0% { transform: translate(0, 0) rotate(0deg); opacity: 1; }\n    45% { transform: translate(-5%, -12%) rotate(-4deg); opacity: 1; }\n    100% { transform: translate(-12%, -46%) rotate(-10deg); opacity: 0; }\n  }\n  @keyframes fx-death-bottom {\n    0% { transform: translate(0, 0) rotate(0deg); opacity: 1; }\n    45% { transform: translate(5%, 12%) rotate(4deg); opacity: 1; }\n    100% { transform: translate(12%, 46%) rotate(10deg); opacity: 0; }\n  }\n  @keyframes fx-death-crack {\n    0% { transform: translateX(-50%) scaleY(0); opacity: 0; }\n    60% { transform: translateX(-50%) scaleY(1); opacity: 1; }\n    100% { transform: translateX(-50%) scaleY(1); opacity: 0; }\n  }\n  @keyframes fx-death-dust {\n    0% { transform: translate(-50%, -50%) scale(0.65); opacity: 0.85; }\n    100% { transform: translate(-50%, -60%) scale(1.12); opacity: 0; }\n  }\n  @keyframes fx-death-fade {\n    0% { opacity: 1; }\n    100% { opacity: 0; }\n  }\n  @keyframes cam-shake {\n    0% { transform: translate(2px, -2px) scale(1.02); }\n    25% { transform: translate(-2px, 2px) scale(1.02); }\n    50% { transform: translate(2px, 2px) scale(1.02); }\n    75% { transform: translate(-2px, -2px) scale(1.02); }\n    100% { transform: translate(0, 0) scale(1); }\n  }\n  @keyframes cam-shake-heavy {\n    0% { transform: translate(4px, -4px) scale(1.05); }\n    20% { transform: translate(-5px, 5px) scale(1.06); }\n    45% { transform: translate(5px, 4px) scale(1.05); }\n    70% { transform: translate(-4px, -5px) scale(1.04); }\n    100% { transform: translate(0, 0) scale(1); }\n  }\n  @keyframes pulse {\n    0% { box-shadow: 0 0 0 0 rgba(255,255,0,0.6); }\n    100% { box-shadow: 0 0 0 12px rgba(255,255,0,0); }\n  }\n\n  /* Telegraph/Impact 高亮 */\n  .cell.highlight-tele { background: rgba(24,144,255,0.28) !important; }\n  .cell.highlight-imp  { background: rgba(245,34,45,0.30) !important; }\n  .cell.highlight-stage{ background: rgba(250,173,20,0.34) !important; }\n\n  /* 技能卡简易样式（含 pink/white/blue） */\n  .skillCard { border-left: 6px solid #91d5ff; background: rgba(255,255,255,0.06); padding: 8px; border-radius: 8px; margin: 6px 0; cursor: pointer; }\n  .skillCard.green { border-left-color:#73d13d; }\n  .skillCard.red   { border-left-color:#ff4d4f; }\n  .skillCard.blue  { border-left-color:#40a9ff; }\n  .skillCard.orange{ border-left-color:#fa8c16; }\n  .skillCard.pink  { border-left-color:#eb2f96; }\n  .skillCard.white { border-left-color:#d9d9d9; }\n  .skillCard.disabled { opacity: 0.55; cursor: not-allowed; }\n  .skillCard .small { font-size: 12px; opacity: 0.85; }\n\n  /* GOD\'S WILL */\n  #godsWillBtn {\n    position: fixed; right: 16px; bottom: 16px; z-index: 3001;\n    padding: 10px 14px; border: none; border-radius: 10px; color: #fff;\n    background: #2f54eb; box-shadow: 0 6px 16px rgba(0,0,0,0.2); cursor: pointer;\n    font-weight: 700; letter-spacing: 0.5px;\n  }\n  #godsWillBtn.armed { background: #722ed1; }\n  #godsWillBtn.locked,\n  #godsWillBtn:disabled {\n    background: #1f1f1f;\n    color: rgba(255,255,255,0.45);\n    cursor: not-allowed;\n    box-shadow: none;\n  }\n\n  /* GOD\'S WILL 菜单 */\n  .gods-menu {\n    position: absolute; z-index: 3002; background: rgba(20,20,30,0.95); color: #fff;\n    border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 8px; min-width: 180px;\n    box-shadow: 0 6px 16px rgba(0,0,0,0.35); backdrop-filter: blur(2px);\n  }\n  .gods-menu .title { font-size: 12px; opacity: 0.8; margin-bottom: 6px; }\n  .gods-menu .row { display: flex; gap: 6px; }\n  .gods-menu button {\n    flex: 1; padding: 6px 8px; border: none; border-radius: 6px; cursor: pointer; font-weight: 700;\n  }\n  .gods-menu .kill { background: #f5222d; color: #fff; }\n  .gods-menu .onehp { background: #faad14; color: #111; }\n  .gods-menu .cancel { background: #434343; color: #fff; }\n\n  /* Fullscreen Button */\n  #fullscreenBtn {\n    position: fixed; left: 16px; bottom: 16px; z-index: 3001;\n    padding: 10px 14px; border: none; border-radius: 10px; color: #fff;\n    background: #13c2c2; box-shadow: 0 6px 16px rgba(0,0,0,0.2); cursor: pointer;\n    font-weight: 700; letter-spacing: 0.5px;\n  }\n  #fullscreenBtn.on { background: #08979c; }\n\n  /* 模拟全屏（不支持原生时的兜底） */\n  html.fs-sim, body.fs-sim { width: 100%; height: 100%; overflow: hidden; }\n  body.fs-sim #battleCamera {\n    position: fixed !important; left: 0; top: 0; width: 100vw; height: 100vh;\n    background: #0b0f1a;\n  }\n  body.fs-sim #battleArea {\n    margin: 0 auto;\n  }\n  `;\n  const style = document.createElement(\'style\'); style.id=\'fx-styles\'; style.textContent=css; document.head.appendChild(style);\n}\nfunction ensureFxLayer(){\n  if(!battleAreaEl) return null;\n  if(!fxLayer){\n    fxLayer=document.createElement(\'div\');\n    fxLayer.className=\'fx-layer\';\n  }\n  if(fxLayer.parentElement!==battleAreaEl){\n    battleAreaEl.appendChild(fxLayer);\n  }\n  return fxLayer;\n}\nfunction getCellEl(r,c){ return document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }\nfunction getCellCenter(r,c){\n  const cell = getCellEl(r,c); const area = battleAreaEl;\n  if(!cell || !area) return {x:0,y:0};\n  const cr = cell.getBoundingClientRect(); const ar = area.getBoundingClientRect();\n  return { x: cr.left - ar.left + cr.width/2, y: cr.top - ar.top + cr.height/2 };\n}\nfunction makeEl(cls, html=\'\'){ const el=document.createElement(\'div\'); el.className=`fx ${cls}`; if(html) el.innerHTML=html; return el; }\nfunction onAnimEndRemove(el, timeout=1200){ const done=()=>el.remove(); el.addEventListener(\'animationend\',done,{once:true}); setTimeout(done, timeout); }\nfunction fxAtCell(r,c,el){ ensureFxLayer(); const p=getCellCenter(r,c); el.style.left=`${p.x}px`; el.style.top=`${p.y}px`; fxLayer.appendChild(el); return el; }\nfunction fxAtPoint(x,y,el){ ensureFxLayer(); el.style.left=`${x}px`; el.style.top=`${y}px`; fxLayer.appendChild(el); return el; }\nfunction getUnitBounds(u){\n  if(!u) return null;\n  const size = Math.max(1, u.size || 1);\n  const tl = getCellEl(u.r, u.c);\n  const br = getCellEl(u.r + size - 1, u.c + size - 1);\n  if(!tl || !br) return null;\n  const left = tl.offsetLeft;\n  const top = tl.offsetTop;\n  const right = br.offsetLeft + br.offsetWidth;\n  const bottom = br.offsetTop + br.offsetHeight;\n  const width = Math.max(0, right - left);\n  const height = Math.max(0, bottom - top);\n  const centerX = left + width / 2;\n  const centerY = top + height / 2;\n  return { left, top, width, height, centerX, centerY };\n}\nfunction getUnitCenterPoint(u){\n  if(!u) return null;\n  const bounds = getUnitBounds(u);\n  if(bounds) return { x: bounds.centerX, y: bounds.centerY };\n  if(typeof u.r === \'number\' && typeof u.c === \'number\') return getCellCenter(u.r, u.c);\n  return null;\n}\nfunction fxAtUnit(u, el){\n  ensureFxLayer();\n  const bounds = getUnitBounds(u);\n  if(!bounds){\n    if(u) return fxAtCell(u.r, u.c, el);\n    return null;\n  }\n  el.style.left = `${bounds.centerX}px`;\n  el.style.top = `${bounds.centerY}px`;\n  el.style.width = `${bounds.width}px`;\n  el.style.height = `${bounds.height}px`;\n  el.style.transform = \'translate(-50%, -50%)\';\n  fxLayer.appendChild(el);\n  return el;\n}\nfunction resolveFxAnchor(target){\n  if(!target) return null;\n  if(typeof target === \'string\'){ const unit = units && units[target]; if(unit) return resolveFxAnchor(unit); }\n  if(target.id && typeof target.r === \'number\' && typeof target.c === \'number\'){\n    const bounds = getUnitBounds(target);\n    if(bounds){\n      const topOffset = Math.min(bounds.height * 0.28, 30);\n      return { x: bounds.centerX, y: bounds.top + topOffset, unit: target };\n    }\n    return resolveFxAnchor({r: target.r, c: target.c});\n  }\n  if(target.unit){ return resolveFxAnchor(target.unit); }\n  if(Array.isArray(target) && target.length>=2){ return resolveFxAnchor({r: target[0], c: target[1]}); }\n  if(typeof target.x === \'number\' && typeof target.y === \'number\'){ return { x: target.x, y: target.y }; }\n  if(typeof target === \'object\' && typeof target.r === \'number\' && typeof target.c === \'number\'){\n    const pt = getCellCenter(target.r, target.c);\n    return { x: pt.x, y: pt.y, r: target.r, c: target.c };\n  }\n  return null;\n}\nfunction showAttackFx({attacker=null, target=null, cell=null, point=null, trueDamage=false, heavy=false}={}){\n  let anchor = null;\n  if(target){\n    if(target.id){ anchor = getUnitCenterPoint(target); }\n    else { anchor = resolveFxAnchor(target); }\n  }\n  if(!anchor && cell){ anchor = resolveFxAnchor(cell); }\n  if(!anchor && point){ anchor = resolveFxAnchor(point); }\n  if(!anchor) return null;\n  const node = makeEl(\'fx-attack\');\n  if(trueDamage) node.classList.add(\'true-damage\');\n  if(heavy) node.classList.add(\'heavy\');\n  node.innerHTML = `\n    <div class="flash"><\/div>\n    <div class="slash main"><\/div>\n    <div class="slash reverse"><\/div>\n    <div class="ring"><\/div>\n    <div class="spark left"><\/div>\n    <div class="spark right"><\/div>\n  `;\n  fxAtPoint(anchor.x, anchor.y, node);\n  let angle = 0;\n  if(attacker){\n    const origin = getUnitCenterPoint(attacker);\n    if(origin){ angle = Math.atan2(anchor.y - origin.y, anchor.x - origin.x) * 180 / Math.PI; }\n  }\n  if(point && typeof point.angle === \'number\'){ angle = point.angle; }\n  node.style.setProperty(\'--fx-angle\', `${angle}deg`);\n  const leftSpark = node.querySelector(\'.spark.left\');\n  if(leftSpark) leftSpark.style.setProperty(\'--spark-angle\', `${angle - 65}deg`);\n  const rightSpark = node.querySelector(\'.spark.right\');\n  if(rightSpark) rightSpark.style.setProperty(\'--spark-angle\', `${angle + 115}deg`);\n  onAnimEndRemove(node, heavy ? 700 : 560);\n  return node;\n}\nfunction showHitFX(r,c, opts={}){ return showAttackFx({cell:{r,c}, ...opts}); }\nfunction resolveSkillFxAnchor({target=null, cell=null, point=null}){\n  let anchor = null;\n  if(target){\n    if(target.id){ anchor = getUnitCenterPoint(target); }\n    else { anchor = resolveFxAnchor(target); }\n  }\n  if(!anchor && cell){ anchor = resolveFxAnchor(cell); }\n  if(!anchor && point){ anchor = resolveFxAnchor(point); }\n  return anchor;\n}\nfunction computeSkillFxAngle(anchor, attacker, fallbackAngle=null){\n  if(fallbackAngle!==null){ return fallbackAngle; }\n  if(attacker){\n    const origin = getUnitCenterPoint(attacker);\n    if(origin){ return Math.atan2(anchor.y - origin.y, anchor.x - origin.x) * 180 / Math.PI; }\n  }\n  return 0;\n}\nfunction makeSkillFxNode(baseClass, html=\'\'){ const node = makeEl(`skill-fx ${baseClass}`.trim(), html); return node; }\nfunction attachSkillFx(node, anchor){ if(!anchor) return null; fxAtPoint(anchor.x, anchor.y, node); return node; }\nfunction buildAttackSwingFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'attack-swing\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#ffffff\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'rgba(255,255,255,0.45)\');\n  node.style.setProperty(\'--attack-angle\', `${angle}deg`);\n  node.dataset.variant = config.variant || \'slash\';\n  const swings = Math.max(1, config.swings || 1);\n  let html = \'<div class="glow"><\/div>\';\n  for(let i=0;i<swings;i++){ html += `<div class="arc" data-index="${i}"><\/div>`; }\n  node.innerHTML = html;\n  const arcs = node.querySelectorAll(\'.arc\');\n  const pivot = (swings - 1) / 2;\n  const spread = config.spread ?? 16;\n  const delayBase = config.delayBase ?? 0;\n  const delayStep = config.delayStep ?? 40;\n  arcs.forEach((el, i)=>{\n    const offset = (i - pivot) * spread;\n    el.style.setProperty(\'--arc-angle-offset\', `${offset}deg`);\n    const delay = delayBase + i * delayStep;\n    if(delay){ el.style.animationDelay = `${delay}ms`; }\n  });\n  onAnimEndRemove(node, config.duration || 460);\n  return attachSkillFx(node, anchor);\n}\nfunction buildAttackMuzzleFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'attack-muzzle\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#ffffff\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'rgba(255,255,255,0.45)\');\n  node.style.setProperty(\'--attack-angle\', `${angle}deg`);\n  node.style.setProperty(\'--attack-length\', `${config.length || 90}px`);\n  node.innerHTML = \'<div class="flash"><\/div><div class="trail"><\/div>\';\n  onAnimEndRemove(node, config.duration || 360);\n  return attachSkillFx(node, anchor);\n}\nfunction buildAttackAuraFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'attack-aura\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#ffffff\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'rgba(255,255,255,0.45)\');\n  node.innerHTML = \'<div class="ring"><\/div><div class="pulse"><\/div>\';\n  onAnimEndRemove(node, config.duration || 520);\n  return attachSkillFx(node, anchor);\n}\nconst SKILL_ATTACK_BUILDERS = {\n  swing: buildAttackSwingFx,\n  muzzle: buildAttackMuzzleFx,\n  aura: buildAttackAuraFx,\n};\nfunction computeFacingAngleForUnit(u){\n  if(!u) return 0;\n  switch(u.facing){\n    case \'left\': return 180;\n    case \'up\': return -90;\n    case \'down\': return 90;\n    default: return 0;\n  }\n}\nfunction computeAttackFxAngle(anchor, ctx, config){\n  if(typeof config.angle === \'number\'){ return config.angle; }\n  const attacker = ctx ? ctx.attacker : null;\n  const targetRef = (config.faceTarget === false) ? null : (ctx ? (ctx.target || ctx.point || ctx.cell || ctx.fxPoint || ctx.fxCell) : null);\n  if(attacker){\n    const attPoint = getUnitCenterPoint(attacker);\n    if(attPoint){\n      if(targetRef){\n        const targetAnchor = resolveFxAnchor(targetRef);\n        if(targetAnchor){\n          const base = Math.atan2(targetAnchor.y - attPoint.y, targetAnchor.x - attPoint.x) * 180 / Math.PI;\n          return typeof config.angleOffset === \'number\' ? base + config.angleOffset : base;\n        }\n      }\n      if(anchor && anchor.x !== undefined && anchor.y !== undefined){\n        const base = Math.atan2(anchor.y - attPoint.y, anchor.x - attPoint.x) * 180 / Math.PI;\n        return typeof config.angleOffset === \'number\' ? base + config.angleOffset : base;\n      }\n      const base = computeFacingAngleForUnit(attacker);\n      return typeof config.angleOffset === \'number\' ? base + config.angleOffset : base;\n    }\n  }\n  return typeof config.angleOffset === \'number\' ? config.angleOffset : 0;\n}\nfunction deriveAttackFxConfig(config){\n  if(!config) return null;\n  switch(config.type){\n    case \'slash\':{\n      const swings = Math.max(1, config.slashes || 1);\n      const variant = config.variant === \'harpoon\' ? \'wide\' : (config.variant || \'slash\');\n      const spread = config.attackSpread ?? (variant === \'wide\' ? 22 : 16);\n      return {type:\'swing\', swings, spread, delayStep: swings>1 ? 34 : 0, variant};\n    }\n    case \'claw\':{\n      const swings = Math.max(1, Math.min(4, config.scratches || 3));\n      const spread = config.attackSpread ?? 14;\n      const variant = config.variant === \'mecha\' ? \'mecha\' : \'claw\';\n      return {type:\'swing\', swings, spread, delayStep: config.delayStep ?? 26, variant};\n    }\n    case \'beam\':{\n      return {type:\'muzzle\', length: Math.max(70, config.length || 120)};\n    }\n    case \'burst\':\n    case \'impact\':\n    case \'aura\':\n    case \'lightning\':\n    case \'rune\':\n    case \'cascade\':\n    case \'spiral\':\n      return {type:\'aura\'};\n    default:\n      return null;\n  }\n}\nfunction showSkillAttackFx(config, ctx={}){\n  if(!config) return null;\n  const builder = SKILL_ATTACK_BUILDERS[config.type];\n  if(!builder) return null;\n  let anchorTarget = ctx ? ctx.attacker : null;\n  if(config.anchor === \'target\'){ anchorTarget = ctx ? ctx.target : anchorTarget; }\n  else if(config.anchor === \'cell\'){ anchorTarget = (ctx && (ctx.fxCell || ctx.cell)) || anchorTarget; }\n  else if(config.anchor === \'point\'){ anchorTarget = (ctx && (ctx.fxPoint || ctx.point)) || anchorTarget; }\n  const anchor = resolveFxAnchor(anchorTarget || (ctx ? ctx.attacker : null));\n  if(!anchor) return null;\n  const angle = computeAttackFxAngle(anchor, ctx, config);\n  return builder({anchor, angle, config, ctx});\n}\nfunction maybeShowAttackFxForSkill(config, ctx){\n  if(!ctx || !ctx.attacker) return;\n  const baseConfig = config || null;\n  const derived = baseConfig && baseConfig.attack ? Object.assign({}, baseConfig.attack) : deriveAttackFxConfig(baseConfig);\n  if(!derived) return;\n  if(baseConfig){\n    if(derived.primary === undefined) derived.primary = baseConfig.primary;\n    if(derived.secondary === undefined) derived.secondary = baseConfig.secondary;\n    if(!derived.variant && baseConfig.variant) derived.variant = baseConfig.variant;\n  }\n  showSkillAttackFx(derived, ctx);\n}\nfunction buildSlashSkillFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'slash\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#fff\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'rgba(255,255,255,0.65)\');\n  node.style.setProperty(\'--skill-spark\', config.spark || \'rgba(255,255,255,0.9)\');\n  node.dataset.variant = config.variant || \'default\';\n  const slashCount = Math.max(1, config.slashes || 2);\n  let slashes = \'\';\n  for(let i=0;i<slashCount;i++){ slashes += `<div class="stroke" data-index="${i}"><\/div>`; }\n  node.innerHTML = `\n    <div class="flash"><\/div>\n    <div class="ring"><\/div>\n    <div class="sparks">\n      <div class="spark left"><\/div>\n      <div class="spark right"><\/div>\n    <\/div>\n    <div class="strokes">${slashes}<\/div>\n  `;\n  node.style.setProperty(\'--skill-angle\', `${angle}deg`);\n  onAnimEndRemove(node, config.duration || 600);\n  return attachSkillFx(node, anchor);\n}\nfunction buildClawSkillFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'claw\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#f0d088\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'#ffefa9\');\n  node.dataset.variant = config.variant || \'default\';\n  const scratchCount = Math.max(3, config.scratches || 3);\n  const scratchSpacing = config.spacing ?? 16;\n  const scratchDelay = config.delayStep ?? 30;\n  const scratchBaseDelay = config.delayBase ?? 0;\n  let scratchHtml=\'\';\n  for(let i=0;i<scratchCount;i++){\n    scratchHtml += `<div class="scratch" data-index="${i}"><span><\/span><\/div>`;\n  }\n  const shardCount = Math.max(0, config.shards|0);\n  let shardHtml=\'\';\n  for(let i=0;i<shardCount;i++){\n    shardHtml += `<div class="shard" data-index="${i}"><\/div>`;\n  }\n  const mechaExtras = config.variant===\'mecha\'\n    ? `<div class="servo-ring"><\/div><div class="servo-flare"><\/div><div class="mecha-sparks"><span class="spark one"><\/span><span class="spark two"><\/span><\/div>`\n    : \'\';\n  node.innerHTML = `<div class="burst"><\/div>${mechaExtras}${shardHtml}${scratchHtml}`;\n  node.style.setProperty(\'--skill-angle\', `${angle}deg`);\n  const scratchEls = node.querySelectorAll(\'.scratch\');\n  const scratchPivot = (scratchCount - 1) / 2;\n  scratchEls.forEach((el,i)=>{\n    const offset = (i - scratchPivot) * scratchSpacing;\n    el.style.setProperty(\'--scratch-shift\', `${offset}px`);\n    const delay = scratchBaseDelay + i * scratchDelay;\n    if(delay){ el.style.animationDelay = `${delay}ms`; }\n  });\n  const shardEls = node.querySelectorAll(\'.shard\');\n  const shardPivot = shardCount > 0 ? (shardCount - 1) / 2 : 0;\n  const shardSpread = config.shardSpread ?? 22;\n  const shardArc = config.shardArc ?? 18;\n  const shardStart = config.shardStartAngle ?? -26;\n  shardEls.forEach((el,i)=>{\n    const drift = (i - shardPivot) * shardSpread;\n    const rot = shardStart + (i - shardPivot) * shardArc;\n    el.style.setProperty(\'--shard-drift\', `${drift}px`);\n    el.style.setProperty(\'--shard-rotate\', `${rot}deg`);\n    el.style.animationDelay = `${90 + i * 45}ms`;\n  });\n  onAnimEndRemove(node, config.duration || 640);\n  return attachSkillFx(node, anchor);\n}\nfunction buildBeamSkillFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'beam\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#ffd77f\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'#fff2c2\');\n  node.style.setProperty(\'--skill-glow\', config.glow || \'rgba(255,255,255,0.8)\');\n  node.dataset.variant = config.variant || \'default\';\n  node.innerHTML = `\n    <div class="muzzle"><\/div>\n    <div class="trail"><\/div>\n    <div class="flare"><\/div>\n  `;\n  node.style.setProperty(\'--skill-angle\', `${angle}deg`);\n  node.style.setProperty(\'--skill-length\', `${config.length || 120}px`);\n  onAnimEndRemove(node, config.duration || 420);\n  return attachSkillFx(node, anchor);\n}\nfunction buildBurstSkillFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'burst\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#8fd3ff\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'#dff4ff\');\n  node.style.setProperty(\'--skill-spark\', config.spark || \'#ffffff\');\n  node.dataset.variant = config.variant || \'default\';\n  node.innerHTML = `\n    <div class="ring"><\/div>\n    <div class="wave"><\/div>\n    <div class="core"><\/div>\n  `;\n  onAnimEndRemove(node, config.duration || 680);\n  return attachSkillFx(node, anchor);\n}\nfunction buildAuraSkillFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'aura\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#ffb86c\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'#ffe9c7\');\n  node.style.setProperty(\'--skill-outline\', config.outline || \'rgba(255,255,255,0.75)\');\n  node.dataset.variant = config.variant || \'default\';\n  node.innerHTML = `\n    <div class="halo"><\/div>\n    <div class="glyph">${config.glyph || \'\'}<\/div>\n    <div class="particles"><\/div>\n  `;\n  onAnimEndRemove(node, config.duration || 900);\n  return attachSkillFx(node, anchor);\n}\nfunction buildLightningSkillFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'lightning\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#ff9cff\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'#ffe6ff\');\n  const bolts = Math.max(2, config.bolts || 3);\n  let html=\'\';\n  for(let i=0;i<bolts;i++){\n    html += `<div class="bolt" data-index="${i}"><\/div>`;\n  }\n  node.innerHTML = `<div class="glow"><\/div>${html}`;\n  node.style.setProperty(\'--skill-angle\', `${angle}deg`);\n  onAnimEndRemove(node, config.duration || 560);\n  return attachSkillFx(node, anchor);\n}\nfunction buildRuneSkillFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'rune\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#b37bff\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'#f0ddff\');\n  node.dataset.variant = config.variant || \'default\';\n  node.innerHTML = `\n    <div class="sigil"><\/div>\n    <div class="orbit"><\/div>\n    <div class="flare"><\/div>\n  `;\n  onAnimEndRemove(node, config.duration || 740);\n  return attachSkillFx(node, anchor);\n}\nfunction buildImpactSkillFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'impact\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#ff6f6f\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'#ffd3d3\');\n  node.innerHTML = `\n    <div class="shock"><\/div>\n    <div class="dust"><\/div>\n    <div class="cracks"><\/div>\n  `;\n  onAnimEndRemove(node, config.duration || 780);\n  return attachSkillFx(node, anchor);\n}\nfunction buildCascadeSkillFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'cascade\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#72e7ff\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'#c6f7ff\');\n  const droplets = Math.max(3, config.droplets || 4);\n  let html=\'\';\n  for(let i=0;i<droplets;i++){\n    html += `<div class="drop" data-index="${i}"><\/div>`;\n  }\n  node.innerHTML = `<div class="column"><\/div>${html}`;\n  onAnimEndRemove(node, config.duration || 800);\n  return attachSkillFx(node, anchor);\n}\nfunction buildSpiralSkillFx({anchor, angle, config}){\n  const node = makeSkillFxNode(\'spiral\');\n  node.style.setProperty(\'--skill-primary\', config.primary || \'#f5f56b\');\n  node.style.setProperty(\'--skill-secondary\', config.secondary || \'#fff9c4\');\n  node.innerHTML = `\n    <div class="swirl one"><\/div>\n    <div class="swirl two"><\/div>\n    <div class="center"><\/div>\n  `;\n  onAnimEndRemove(node, config.duration || 760);\n  return attachSkillFx(node, anchor);\n}\nconst SKILL_FX_BUILDERS = {\n  slash: buildSlashSkillFx,\n  claw: buildClawSkillFx,\n  beam: buildBeamSkillFx,\n  burst: buildBurstSkillFx,\n  aura: buildAuraSkillFx,\n  lightning: buildLightningSkillFx,\n  rune: buildRuneSkillFx,\n  impact: buildImpactSkillFx,\n  cascade: buildCascadeSkillFx,\n  spiral: buildSpiralSkillFx,\n};\nconst SKILL_FX_CONFIG = {\n  \'adora:短匕轻挥\':        {type:\'slash\', primary:\'#ff82b6\', secondary:\'rgba(255,158,206,0.55)\', spark:\'#ffe5f5\', slashes:2},\n  \'adora:呀！你不要靠近我呀！！\': {type:\'spiral\', primary:\'#ff9f6a\', secondary:\'#ffe0c1\'},\n  \'adora:自制粉色迷你电击装置\': {type:\'lightning\', primary:\'#ff87ff\', secondary:\'#ffd7ff\', bolts:4},\n  \'adora:略懂的医术！\':     {type:\'aura\', primary:\'#75e6a7\', secondary:\'#c6ffde\', outline:\'rgba(255,255,255,0.85)\', glyph:\'✚\'},\n  \'adora:加油哇！\':         {type:\'aura\', primary:\'#ffcf74\', secondary:\'#ffe9bb\', glyph:\'★\'},\n  \'adora:只能靠你了。。\':   {type:\'impact\', primary:\'#ff6161\', secondary:\'#ffd6d6\'},\n  \'adora:枪击\':             {type:\'beam\', primary:\'#ffd780\', secondary:\'#fff1c2\', glow:\'rgba(255,255,255,0.9)\', variant:\'adora\'},\n  \'dario:机械爪击\':         {type:\'claw\', primary:\'#f6c55b\', secondary:\'#fff3c7\', scratches:4, spacing:14, delayStep:22, shards:3, shardSpread:12, shardArc:10, shardStartAngle:-24, variant:\'mecha\', attack:{type:\'swing\', swings:2, spread:12, delayStep:32, variant:\'mecha\'}},\n  \'dario:枪击\':             {type:\'beam\', primary:\'#9ee0ff\', secondary:\'#dcf6ff\', glow:\'rgba(255,255,255,0.85)\', variant:\'dario\'},\n  \'dario:迅捷步伐\':         {type:\'spiral\', primary:\'#7fe8ff\', secondary:\'#d6f8ff\'},\n  \'dario:拿来吧你！\':       {type:\'claw\', primary:\'#ffa56a\', secondary:\'#ffd7b9\', scratches:5},\n  \'dario:先苦后甜\':         {type:\'aura\', primary:\'#c9a4ff\', secondary:\'#eedcff\', glyph:\'↻\'},\n  \'karma:沙包大的拳头\':     {type:\'slash\', primary:\'#ff9059\', secondary:\'rgba(255,192,160,0.7)\', spark:\'#fff0e4\', slashes:1},\n  \'karma:枪击\':             {type:\'beam\', primary:\'#f38fff\', secondary:\'#ffd9ff\', glow:\'rgba(255,255,255,0.85)\', variant:\'karma\'},\n  \'karma:都听你的\':         {type:\'spiral\', primary:\'#ffdd77\', secondary:\'#fff1bd\'},\n  \'karma:嗜血之握\':         {type:\'claw\', primary:\'#d95ffb\', secondary:\'#f0b8ff\', scratches:3},\n  \'karma:深呼吸\':           {type:\'aura\', primary:\'#7ecfff\', secondary:\'#d7f1ff\', glyph:\'息\'},\n  \'haz:鱼叉穿刺\':           {type:\'beam\', primary:\'#5fd9ff\', secondary:\'#c5f2ff\', glow:\'rgba(255,255,255,0.8)\', variant:\'harpoon\'},\n  \'haz:深海猎杀\':           {type:\'slash\', primary:\'#4ecdf2\', secondary:\'rgba(170,236,255,0.6)\', spark:\'#e3fbff\', slashes:3, attack:{type:\'swing\', swings:3, spread:24, delayStep:36, variant:\'wide\', faceTarget:false}},\n  \'haz:猎神之叉\':           {type:\'slash\', primary:\'#ffe373\', secondary:\'rgba(255,233,152,0.7)\', spark:\'#fff6c4\', slashes:2, attack:{type:\'swing\', swings:2, spread:22, delayStep:30, variant:\'wide\', faceTarget:false}},\n  \'haz:锁链缠绕\':           {type:\'rune\', primary:\'#8ed8ff\', secondary:\'#dff3ff\', variant:\'chain\'},\n  \'haz:鲸落\':               {type:\'cascade\', primary:\'#8ae8ff\', secondary:\'#d5f9ff\', droplets:6},\n  \'haz:怨念滋生\':           {type:\'rune\', primary:\'#b56fff\', secondary:\'#eed4ff\', variant:\'curse\'},\n  \'haz:付出代价\':           {type:\'slash\', primary:\'#ff6d6d\', secondary:\'rgba(255,158,158,0.7)\', spark:\'#ffd3d3\', slashes:4, attack:{type:\'swing\', swings:3, spread:26, delayStep:30, variant:\'wide\', faceTarget:false}},\n  \'haz:仇恨之叉\':           {type:\'slash\', primary:\'#ffa365\', secondary:\'rgba(255,202,153,0.7)\', spark:\'#ffe7d4\', slashes:4, attack:{type:\'swing\', swings:3, spread:24, delayStep:30, variant:\'wide\', faceTarget:false}},\n  \'haz:怨念滋生·恐惧\':      {type:\'rune\', primary:\'#9c60ff\', secondary:\'#e4ceff\', variant:\'fear\'},\n  \'haz:锁链缠绕·增益\':      {type:\'aura\', primary:\'#74b2ff\', secondary:\'#cce0ff\', glyph:\'链\'},\n  \'haz:锁链缠绕·反击\':      {type:\'burst\', primary:\'#9ad9ff\', secondary:\'#e3f4ff\'},\n  \'katz:矛刺\':              {type:\'beam\', primary:\'#ff886d\', secondary:\'#ffd5c6\', variant:\'spear\'},\n  \'katz:链式鞭击\':          {type:\'slash\', primary:\'#ff586f\', secondary:\'rgba(255,163,177,0.7)\', spark:\'#ffd2da\', slashes:3},\n  \'katz:反复鞭尸\':          {type:\'slash\', primary:\'#ff4d9d\', secondary:\'rgba(255,164,210,0.7)\', spark:\'#ffd4ec\', slashes:5},\n  \'katz:终焉礼炮\':          {type:\'beam\', primary:\'#ff6f3f\', secondary:\'#ffc8aa\', variant:\'cannon\', length:180},\n  \'katz:必须抹杀一切。。\':  {type:\'rune\', primary:\'#ff6666\', secondary:\'#ffd1d1\', variant:\'obliterate\'},\n  \'tusk:骨盾猛击\':          {type:\'impact\', primary:\'#d2c4ff\', secondary:\'#f1ebff\'},\n  \'tusk:来自深海的咆哮\':    {type:\'burst\', primary:\'#84dfff\', secondary:\'#d3f4ff\'},\n  \'tusk:战争堡垒\':          {type:\'aura\', primary:\'#a0b7ff\', secondary:\'#dde5ff\', glyph:\'堡\'},\n  \'tusk:牛鲨冲撞\':          {type:\'impact\', primary:\'#ffe483\', secondary:\'#fff3bd\'},\n  \'tusk:拼尽全力保卫队长\':  {type:\'aura\', primary:\'#ff9e7f\', secondary:\'#ffd0c2\', glyph:\'盾\'},\n  \'neyla:迅捷射击\':         {type:\'beam\', primary:\'#ff7dce\', secondary:\'#ffd6f0\', variant:\'rapid\'},\n  \'neyla:穿刺狙击\':         {type:\'beam\', primary:\'#ffdf7c\', secondary:\'#fff0c1\', variant:\'sniper\', length:200},\n  \'neyla:双钩牵制\':         {type:\'claw\', primary:\'#ff9a9a\', secondary:\'#ffd8d8\', scratches:2},\n  \'neyla:终末之影\':         {type:\'rune\', primary:\'#ff9df2\', secondary:\'#ffd9fa\', variant:\'doom\'},\n  \'neyla:执行……\':          {type:\'beam\', primary:\'#b3a4ff\', secondary:\'#e8e2ff\', variant:\'execution\', length:140},\n  \'kyn:迅影突刺\':           {type:\'slash\', primary:\'#8ef9ff\', secondary:\'rgba(206,253,255,0.7)\', spark:\'#f0feff\', slashes:2},\n  \'kyn:死亡宣告\':           {type:\'rune\', primary:\'#ff8383\', secondary:\'#ffd6d6\', variant:\'doom\'},\n  \'kyn:割喉飞刃\':           {type:\'slash\', primary:\'#ff5f9f\', secondary:\'rgba(255,176,212,0.7)\', spark:\'#ffdff0\', slashes:3},\n  \'kyn:影杀之舞\':           {type:\'burst\', primary:\'#b57dff\', secondary:\'#e8d6ff\', variant:\'dance\'},\n  \'kyn:自我了断。。\':       {type:\'impact\', primary:\'#7d95ff\', secondary:\'#d5deff\'},\n};\nfunction showSkillFx(skillKey, ctx={}){\n  if(!skillKey){ return showAttackFx(ctx); }\n  const config = SKILL_FX_CONFIG[skillKey];\n  if(!config){ return showAttackFx(ctx); }\n  maybeShowAttackFxForSkill(config, ctx);\n  const builder = SKILL_FX_BUILDERS[config.type];\n  if(!builder){ return showAttackFx(ctx); }\n  const anchor = resolveSkillFxAnchor(ctx);\n  if(!anchor){ return null; }\n  const angle = computeSkillFxAngle(anchor, ctx.attacker, typeof ctx.angle === \'number\' ? ctx.angle : null);\n  return builder({anchor, angle, config, ctx});\n}\nfunction showDeathFx(u){\n  if(!u || !battleAreaEl) return;\n  const node = makeEl(\'fx-death\');\n  node.classList.add(u.side === \'player\' ? \'player\' : \'enemy\');\n  const size = Math.max(1, u.size || 1);\n  if(size > 1){ node.classList.add(`size-${size}`); }\n  node.innerHTML = `\n    <div class="piece top"><\/div>\n    <div class="piece bottom"><\/div>\n    <div class="crack"><\/div>\n    <div class="dust"><\/div>\n  `;\n  const attached = fxAtUnit(u, node);\n  if(attached){\n    onAnimEndRemove(attached, 1200);\n  }\n}\nfunction spawnFloatText(target,text,{className=\'\', offsetX=0, offsetY=-28, zOffset=0}={}){\n  const anchor = resolveFxAnchor(target);\n  if(!anchor) return null;\n  const el = makeEl(`fx-number fx-float ${className}`.trim(), text);\n  el.style.left = `${anchor.x}px`;\n  el.style.top = `${anchor.y}px`;\n  el.style.setProperty(\'--fx-offset-x\', `${offsetX}px`);\n  el.style.setProperty(\'--fx-offset-y\', `${offsetY}px`);\n  if(zOffset){ el.style.zIndex = String(100 + zOffset); }\n  ensureFxLayer();\n  fxLayer.appendChild(el);\n  onAnimEndRemove(el,900);\n  return el;\n}\nfunction showDamageFloat(target,hp,sp){\n  if(sp>0){\n    const offsetY = hp>0 ? -20 : -40;\n    spawnFloatText(target,`-${sp}`, {className:\'sp damage\', offsetY, zOffset:1});\n  }\n  if(hp>0){\n    const offsetY = sp>0 ? -56 : -40;\n    spawnFloatText(target,`-${hp}`, {className:\'hp damage\', offsetY, zOffset:2});\n  }\n}\nfunction showGainFloat(target,hp,sp){\n  if(sp>0){\n    const offsetY = hp>0 ? -20 : -40;\n    spawnFloatText(target,`+${sp}`, {className:\'sp heal\', offsetY, zOffset:1});\n  }\n  if(hp>0){\n    const offsetY = sp>0 ? -56 : -40;\n    spawnFloatText(target,`+${hp}`, {className:\'hp heal\', offsetY, zOffset:2});\n  }\n}\nfunction showStatusFloat(target,label,{type=\'buff\', delta=null, offsetY=-72}={}){\n  let text = label;\n  if(delta!==null && delta!==0){\n    const sign = delta>0 ? \'+\' : \'\';\n    text += `${sign}${delta}`;\n  }\n  return spawnFloatText(target,text,{className:`status ${type}`, offsetY, zOffset:3});\n}\nfunction refreshSpCrashVulnerability(u){\n  if(!u) return;\n  const stunnedStacks = u.status ? (u.status.stunned || 0) : 0;\n  if(u._spCrashVuln && stunnedStacks <= 0 && u.sp > 0){\n    u._spCrashVuln = false;\n    appendLog(`${u.name} 的 SP 崩溃易伤解除`);\n  }\n}\nfunction syncSpBroken(u){\n  if(!u) return;\n  u._spBroken = (u.sp <= 0);\n  if(!u._spBroken){\n    refreshSpCrashVulnerability(u);\n  }\n}\nfunction updateStatusStacks(u,key,next,{label,type=\'buff\', offsetY=-72}={}){\n  if(!u || !u.status) return next;\n  const prev = u.status[key] || 0;\n  const value = next;\n  u.status[key] = value;\n  const diff = value - prev;\n  if(diff !== 0){\n    showStatusFloat(u,label,{type, delta: diff, offsetY});\n  }\n  if(key === \'stunned\'){\n    refreshSpCrashVulnerability(u);\n  }\n  return value;\n}\nfunction addStatusStacks(u,key,delta,opts){\n  if(!u || !u.status || !delta) return (u && u.status) ? (u.status[key] || 0) : 0;\n  const prev = u.status[key] || 0;\n  return updateStatusStacks(u,key, prev + delta, opts);\n}\nfunction pulseCell(r,c){ const cell=getCellEl(r,c); if(!cell) return; cell.classList.add(\'pulse\'); setTimeout(()=>cell.classList.remove(\'pulse\'),620); }\nfunction applyCameraTransform(){\n  if(!battleAreaEl) return;\n  battleAreaEl.style.setProperty(\'--cam-scale\', cameraState.scale.toFixed(4));\n  battleAreaEl.style.setProperty(\'--cam-tx\', `${cameraState.x.toFixed(2)}px`);\n  battleAreaEl.style.setProperty(\'--cam-ty\', `${cameraState.y.toFixed(2)}px`);\n}\nfunction clampCameraTargets(){\n  if(!mapPaneEl) return;\n  const vw = mapPaneEl.clientWidth || BOARD_WIDTH;\n  const vh = mapPaneEl.clientHeight || BOARD_HEIGHT;\n  const scale = cameraState.targetScale;\n  const scaledWidth = BOARD_WIDTH * scale;\n  const scaledHeight = BOARD_HEIGHT * scale;\n  const maxX = Math.max(0, (scaledWidth - vw) / 2);\n  const maxY = Math.max(0, (scaledHeight - vh) / 2);\n  cameraState.targetX = clampValue(cameraState.targetX, -maxX, maxX);\n  cameraState.targetY = clampValue(cameraState.targetY, -maxY, maxY);\n  cameraState.x = clampValue(cameraState.x, -maxX, maxX);\n  cameraState.y = clampValue(cameraState.y, -maxY, maxY);\n}\nfunction updateCameraBounds(){\n  if(!mapPaneEl) return;\n  const vw = mapPaneEl.clientWidth || BOARD_WIDTH;\n  const vh = mapPaneEl.clientHeight || BOARD_HEIGHT;\n  const fitScale = Math.min(vw / BOARD_WIDTH, vh / BOARD_HEIGHT) || 1;\n  const base = Math.min(1, fitScale);\n  cameraState.baseScale = base;\n  cameraState.minScale = Math.max(0.45, base * 0.6);\n  cameraState.maxScale = Math.max(base * 2.2, base * 1.1);\n  cameraState.targetScale = clampValue(cameraState.targetScale || base, cameraState.minScale, cameraState.maxScale);\n  cameraState.scale = clampValue(cameraState.scale || base, cameraState.minScale, cameraState.maxScale);\n  clampCameraTargets();\n  applyCameraTransform();\n}\nfunction startCameraLoop(){\n  if(cameraLoopHandle) return;\n  const step = ()=>{\n    const stiffness = 0.10;\n    const damping = 0.86;\n\n    cameraState.vx += (cameraState.targetX - cameraState.x) * stiffness;\n    cameraState.vx *= damping;\n    cameraState.x += cameraState.vx;\n\n    cameraState.vy += (cameraState.targetY - cameraState.y) * stiffness;\n    cameraState.vy *= damping;\n    cameraState.y += cameraState.vy;\n\n    cameraState.vs += (cameraState.targetScale - cameraState.scale) * stiffness;\n    cameraState.vs *= damping;\n    cameraState.scale += cameraState.vs;\n\n    if(Math.abs(cameraState.x - cameraState.targetX) < 0.05 && Math.abs(cameraState.vx) < 0.05){ cameraState.x = cameraState.targetX; cameraState.vx = 0; }\n    if(Math.abs(cameraState.y - cameraState.targetY) < 0.05 && Math.abs(cameraState.vy) < 0.05){ cameraState.y = cameraState.targetY; cameraState.vy = 0; }\n    if(Math.abs(cameraState.scale - cameraState.targetScale) < 0.001 && Math.abs(cameraState.vs) < 0.001){ cameraState.scale = cameraState.targetScale; cameraState.vs = 0; }\n\n    applyCameraTransform();\n    cameraLoopHandle = requestAnimationFrame(step);\n  };\n  cameraLoopHandle = requestAnimationFrame(step);\n}\nfunction stopCameraLoop(){ if(cameraLoopHandle){ cancelAnimationFrame(cameraLoopHandle); cameraLoopHandle = null; } }\nfunction setCameraTarget({x=cameraState.targetX, y=cameraState.targetY, scale=cameraState.targetScale, immediate=false}={}){\n  cameraState.targetScale = clampValue(scale, cameraState.minScale, cameraState.maxScale);\n  cameraState.targetX = x;\n  cameraState.targetY = y;\n  clampCameraTargets();\n  if(immediate){\n    cameraState.x = cameraState.targetX;\n    cameraState.y = cameraState.targetY;\n    cameraState.scale = cameraState.targetScale;\n    cameraState.vx = cameraState.vy = cameraState.vs = 0;\n    applyCameraTransform();\n  } else {\n    startCameraLoop();\n  }\n}\nfunction cameraReset({immediate=false}={}){\n  if(cameraResetTimer){ clearTimeout(cameraResetTimer); cameraResetTimer=null; }\n  setCameraTarget({x:0, y:0, scale:cameraState.baseScale, immediate});\n}\nfunction cellCenterOffset(r,c){\n  const centerX = BOARD_BORDER + BOARD_PADDING + (c - 1) * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;\n  const centerY = BOARD_BORDER + BOARD_PADDING + (r - 1) * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;\n  return {\n    x: centerX - BOARD_WIDTH / 2,\n    y: centerY - BOARD_HEIGHT / 2,\n  };\n}\nfunction cameraFocusOnCell(r,c,{scale=null, hold=enemyActionCameraLock?0:360, immediate=false}={}){\n  if(!battleAreaEl || !mapPaneEl) return;\n  const offset = cellCenterOffset(r,c);\n  const desiredScale = clampValue(scale===null ? Math.min(cameraState.baseScale * 1.2, cameraState.maxScale) : scale, cameraState.minScale, cameraState.maxScale);\n  const tx = -offset.x * desiredScale;\n  const ty = -offset.y * desiredScale;\n  setCameraTarget({x:tx, y:ty, scale:desiredScale, immediate});\n  if(cameraResetTimer){ clearTimeout(cameraResetTimer); cameraResetTimer=null; }\n  if(hold>0){\n    cameraResetTimer = setTimeout(()=> cameraReset(), hold);\n  }\n}\nfunction cameraShake(intensity=\'normal\'){\n  if(!battleAreaEl) return;\n  const cls = intensity===\'heavy\' ? \'shake-heavy\' : \'shake\';\n  battleAreaEl.classList.remove(\'shake\',\'shake-heavy\');\n  void battleAreaEl.offsetWidth;\n  battleAreaEl.classList.add(cls);\n  const duration = intensity===\'heavy\' ? 360 : 220;\n  setTimeout(()=> battleAreaEl && battleAreaEl.classList.remove(cls), duration);\n}\nfunction zoomCamera(multiplier, focusEvent=null){\n  if(!mapPaneEl) return;\n  const prevScale = cameraState.targetScale;\n  const nextScale = clampValue(prevScale * multiplier, cameraState.minScale, cameraState.maxScale);\n  if(Math.abs(nextScale - prevScale) < 0.0001) return;\n\n  let focusX = 0;\n  let focusY = 0;\n  if(focusEvent){\n    const rect = mapPaneEl.getBoundingClientRect();\n    focusX = (focusEvent.clientX - (rect.left + rect.width/2));\n    focusY = (focusEvent.clientY - (rect.top + rect.height/2));\n  }\n  const ratio = nextScale / prevScale;\n  const newX = cameraState.targetX - focusX * (ratio - 1);\n  const newY = cameraState.targetY - focusY * (ratio - 1);\n  setCameraTarget({x:newX, y:newY, scale:nextScale});\n}\nfunction registerCameraInputs(){\n  if(!mapPaneEl || cameraInputsRegistered) return;\n  cameraInputsRegistered = true;\n  mapPaneEl.addEventListener(\'wheel\', (e)=>{\n    e.preventDefault();\n    if(interactionLocked) return;\n    const factor = e.deltaY < 0 ? 1.06 : 0.94;\n    zoomCamera(factor, e);\n  }, {passive:false});\n  mapPaneEl.addEventListener(\'contextmenu\', (e)=> e.preventDefault());\n  mapPaneEl.addEventListener(\'mousedown\', (e)=>{\n    if(e.button!==2 || interactionLocked) return;\n    e.preventDefault();\n    cameraDragState = { startX: e.clientX, startY: e.clientY, originX: cameraState.targetX, originY: cameraState.targetY };\n    mapPaneEl.classList.add(\'dragging\');\n  });\n  window.addEventListener(\'mousemove\', (e)=>{\n    if(!cameraDragState) return;\n    const dx = e.clientX - cameraDragState.startX;\n    const dy = e.clientY - cameraDragState.startY;\n    setCameraTarget({x: cameraDragState.originX + dx, y: cameraDragState.originY + dy});\n  });\n  window.addEventListener(\'mouseup\', (e)=>{\n    if(e.button!==2 || !cameraDragState) return;\n    cameraDragState = null;\n    if(mapPaneEl) mapPaneEl.classList.remove(\'dragging\');\n  });\n}\nfunction createCameraControls(){\n  if(!mapPaneEl) return;\n  if(cameraControlsEl && cameraControlsEl.isConnected) cameraControlsEl.remove();\n  cameraControlsEl = document.createElement(\'div\');\n  cameraControlsEl.className = \'cameraControls\';\n  const zoomInBtn = document.createElement(\'button\');\n  zoomInBtn.type=\'button\';\n  zoomInBtn.textContent = \'+\';\n  zoomInBtn.title = \'放大\';\n  zoomInBtn.addEventListener(\'click\', ()=>{ if(interactionLocked) return; zoomCamera(1.10); });\n  const zoomOutBtn = document.createElement(\'button\');\n  zoomOutBtn.type=\'button\';\n  zoomOutBtn.textContent = \'−\';\n  zoomOutBtn.title = \'缩小\';\n  zoomOutBtn.addEventListener(\'click\', ()=>{ if(interactionLocked) return; zoomCamera(0.92); });\n  cameraControlsEl.appendChild(zoomInBtn);\n  cameraControlsEl.appendChild(zoomOutBtn);\n  mapPaneEl.appendChild(cameraControlsEl);\n}\n\n// —— Telegraph/Impact 工具 —— \nfunction sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }\nfunction setInteractionLocked(on){\n  interactionLocked = !!on;\n  document.body.classList.toggle(\'interaction-locked\', interactionLocked);\n  if(interactionLocked && cameraDragState){\n    cameraDragState = null;\n    if(mapPaneEl) mapPaneEl.classList.remove(\'dragging\');\n  }\n  if(interactionLocked) clearSkillAiming();\n}\nfunction ensureRoundBanner(){\n  if(!roundBannerEl){\n    roundBannerEl = document.createElement(\'div\');\n    roundBannerEl.className = \'roundBanner\';\n    const inner = document.createElement(\'div\');\n    inner.className = \'text\';\n    roundBannerEl.appendChild(inner);\n    document.body.appendChild(roundBannerEl);\n  }\n  return roundBannerEl;\n}\nfunction showRoundBanner(text, duration=1800){\n  const el = ensureRoundBanner();\n  const inner = el.querySelector(\'.text\');\n  if(inner) inner.textContent = text;\n  el.classList.add(\'show\');\n  setTimeout(()=> el.classList.remove(\'show\'), duration);\n}\nfunction ensureIntroDialog(){\n  if(!introDialogEl){\n    introDialogEl = document.createElement(\'div\');\n    introDialogEl.className = \'introDialog\';\n    introDialogEl.style.display = \'none\';\n    const box = document.createElement(\'div\');\n    box.className = \'box\';\n    const speaker = document.createElement(\'div\');\n    speaker.className = \'speaker\';\n    speaker.textContent = \'Haz\';\n    box.appendChild(speaker);\n    const content = document.createElement(\'div\');\n    content.className = \'content\';\n    box.appendChild(content);\n    const hint = document.createElement(\'div\');\n    hint.className = \'hint\';\n    hint.textContent = \'点击继续\';\n    box.appendChild(hint);\n    introDialogEl.appendChild(box);\n    document.body.appendChild(introDialogEl);\n  }\n  return introDialogEl;\n}\nfunction showIntroLine(text){\n  const dialog = ensureIntroDialog();\n  const content = dialog.querySelector(\'.content\');\n  if(content) content.textContent = text;\n  dialog.style.display = \'flex\';\n  return new Promise(resolve=>{\n    const handler = ()=>{\n      dialog.removeEventListener(\'click\', handler);\n      try{ if(!document.fullscreenElement){ toggleFullscreen(); } }catch(e){}\n      resolve();\n    };\n    dialog.addEventListener(\'click\', handler, {once:true});\n  });\n}\nfunction hideIntroDialog(){ if(introDialogEl){ introDialogEl.style.display = \'none\'; } }\nasync function playIntroCinematic(){\n  if(introPlayed) return;\n  introPlayed = true;\n  setInteractionLocked(true);\n  cameraReset({immediate:true});\n  await sleep(260);\n  const haz = units[\'haz\'];\n  if(haz && haz.hp>0){\n    const zoom = clampValue(cameraState.baseScale * 1.3, cameraState.minScale, cameraState.maxScale);\n    cameraFocusOnCell(haz.r, haz.c, {scale: zoom, hold:0});\n    await sleep(420);\n  }\n  await showIntroLine(\'这种躲躲藏藏遮遮掩掩的人绝对不是什么好东西\');\n  await showIntroLine(\'准备好队员们，今晚不出意外的话，又能钓到一条大的。。。\');\n  hideIntroDialog();\n  cameraReset();\n  await sleep(520);\n  showRoundBanner(\'回合一\', 1800);\n  await sleep(1600);\n  setInteractionLocked(false);\n}\nfunction uniqueCells(cells){ const s=new Set(); const out=[]; for(const c of cells||[]){ const k=`${c.r},${c.c}`; if(!s.has(k)){ s.add(k); out.push(c);} } return out; }\nfunction addTempClassToCells(cells, cls, ms){\n  const arr=uniqueCells(cells);\n  for(const c of arr){ const el=getCellEl(c.r,c.c); if(el) el.classList.add(cls); }\n  setTimeout(()=>{ for(const c of arr){ const el=getCellEl(c.r,c.c); if(el) el.classList.remove(cls); } }, ms);\n}\nasync function telegraphThenImpact(cells){\n  const arr=uniqueCells(cells);\n  addTempClassToCells(arr, \'highlight-tele\', TELEGRAPH_MS);\n  await sleep(TELEGRAPH_MS);\n  addTempClassToCells(arr, \'highlight-imp\', IMPACT_MS);\n  await sleep(IMPACT_MS);\n}\nasync function stageMark(cells){\n  const arr=uniqueCells(cells);\n  addTempClassToCells(arr, \'highlight-stage\', STAGE_MS);\n  await sleep(STAGE_MS);\n}\n\n// —— 叠层眩晕 & SP 崩溃 —— \nfunction applyStunOrStack(target, layers=1, {reason=\'\', bypass=false}={}){\n  const u = target; if(!u || u.hp<=0) return;\n  if(bypass){\n    const next = Math.max(1, (u.status.stunned||0) + 1);\n    updateStatusStacks(u,\'stunned\', next, {label:\'眩晕\', type:\'debuff\'});\n    if(reason) appendLog(`${u.name} 因${reason}，陷入眩晕`);\n    return;\n  }\n  const thr = Math.max(1, u.stunThreshold || 1);\n  u._staggerStacks = (u._staggerStacks || 0) + Math.max(1, layers);\n  appendLog(`${u.name} 眩晕叠层 +${layers}（${u._staggerStacks}/${thr}）`);\n  if(u._staggerStacks >= thr){\n    u._staggerStacks = 0;\n    const next = Math.max(1, (u.status.stunned||0) + 1);\n    updateStatusStacks(u,\'stunned\', next, {label:\'眩晕\', type:\'debuff\'});\n    if(reason) appendLog(`${u.name} 叠层达到门槛，陷入眩晕`);\n  }\n}\nfunction handleSpCrashIfNeeded(u){\n  if(!u || u.hp<=0) return;\n  if(u.sp <= 0 && !u._spBroken){\n    u._spBroken = true;\n    if(!u._spCrashVuln){\n      u._spCrashVuln = true;\n      showStatusFloat(u,\'SP崩溃易伤\',{type:\'debuff\', offsetY:-88});\n      appendLog(`${u.name} 处于 SP 崩溃易伤：受到的伤害翻倍，直到眩晕解除且 SP 恢复`);\n    }\n    applyStunOrStack(u, 1, {bypass:true, reason:\'SP崩溃\'});\n    if(u.side===\'player\'){ playerSteps = Math.max(0, playerSteps - 1); } else { enemySteps = Math.max(0, enemySteps - 1); }\n    const restored = Math.floor(u.maxSp * u.restoreOnZeroPct);\n    u.spPendingRestore = Math.max(u.spPendingRestore ?? 0, restored);\n    appendLog(`${u.name} 的 SP 崩溃：下个己方回合自动恢复至 ${u.spPendingRestore}`);\n  }\n  if(u.sp > 0 && u._spBroken) u._spBroken = false;\n  if(u.sp > 0){\n    refreshSpCrashVulnerability(u);\n  }\n}\nfunction applySpDamage(targetOrId, amount, {sourceId=null, reason=null}={}){\n  const u = typeof targetOrId === \'string\' ? units[targetOrId] : targetOrId;\n  if(!u || u.hp<=0 || amount<=0) return 0;\n  const before = u.sp;\n  u.sp = Math.max(0, u.sp - amount);\n  const delta = before - u.sp;\n  if(delta>0){\n    showDamageFloat(u,0,delta);\n    if(reason){ appendLog(reason.replace(\'{delta}\', String(delta))); }\n    handleSpCrashIfNeeded(u);\n    renderAll();\n  }\n  return delta;\n}\n\n// —— 伤害计算 —— \nfunction backstabMultiplier(attacker,target){\n  const fromBehind = (target.facing === \'right\' && attacker.c < target.c) || (target.facing === \'left\' && attacker.c > target.c);\n  if(fromBehind && attacker.side !== target.side){ appendLog(\'背刺触发 x1.5 伤害！\'); return 1.5; }\n  if(attacker.id === \'adora\' && attacker.sp < 10) return 1.5;\n  return 1.0;\n}\nfunction hasDeepBreathPassive(attacker){\n  if(!attacker || attacker.id!==\'karma\') return false;\n  const pool = attacker.skillPool || [];\n  return pool.some(s=>s && s.name === \'深呼吸\');\n}\nfunction calcOutgoingDamage(attacker, baseDmg, target, skillName){\n  let dmg = baseDmg;\n  if(attacker.passives.includes(\'fearBuff\') && attacker.sp<10) dmg = Math.round(dmg*1.5);\n  if(attacker.passives.includes(\'pride\')){\n    const lostRatio = (attacker.maxHp - attacker.hp) / attacker.maxHp;\n    dmg = Math.round(dmg * (1 + lostRatio * 0.5));\n  }\n  if(attacker.id===\'karma\' && skillName===\'沙包大的拳头\' && (attacker.consecAttacks||0)>=1){ dmg = Math.round(dmg*1.5); }\n  if(attacker.id===\'adora\' && skillName===\'短匕轻挥\' && target){ dmg = Math.round(dmg * backstabMultiplier(attacker,target)); }\n  if(attacker.team===\'seven\'){ dmg = Math.max(0, dmg - 5); }\n  if(attacker.id===\'haz\' && attacker.hp <= attacker.maxHp/2){ dmg = Math.round(dmg * 1.3); }\n  if(attacker.id===\'haz\' && attacker._comeback) dmg = Math.round(dmg * 1.10);\n\n  if(hasDeepBreathPassive(attacker)){\n    dmg = Math.round(dmg * 1.10);\n  }\n\n  const withinCritWindow = roundsPassed <= 15;\n  if(attacker.team===\'seven\' && withinCritWindow && Math.random() < 0.30){ dmg = Math.round(dmg * 1.5); appendLog(`${attacker.name} 暴击！伤害 x1.5`); }\n\n  if(attacker.team===\'seven\' && target && hazMarkedTargetId && target.id===hazMarkedTargetId){ dmg = Math.round(dmg * 1.15); }\n  if(attacker.id===\'tusk\' && (attacker.tuskRageStacks||0)>0){ dmg += 5*attacker.tuskRageStacks; appendLog(`Tusk 猛牛之力：额外 +${5*attacker.tuskRageStacks} 伤害`); attacker.tuskRageStacks = 0; }\n  return dmg;\n}\nfunction damageUnit(id, hpDmg, spDmg, reason, sourceId=null, opts={}){\n  const u = units[id]; if(!u || u.hp<=0) return;\n\n  const source = sourceId ? units[sourceId] : null;\n  const buffStage = opts.buffStage || \'final\';\n  let trueDamage = !!opts.trueDamage;\n\n  if(source && source !== u){\n    const dirToTarget = cardinalDirFromDelta(u.r - source.r, u.c - source.c);\n    setUnitFacing(source, dirToTarget);\n  }\n\n  if(source){\n    if(source.side === u.side){ appendLog(`友伤无效：${source.name} -> ${u.name}`); return; }\n\n    if(!opts.ignoreJixue && buffStage===\'final\' && source.status && source.status.jixueStacks>0){\n      if(!source._jixueActivated){\n        appendLog(`${source.name} 的“鸡血”触发：伤害 x2`);\n        source._jixueActivated = true;\n      }\n      hpDmg = Math.round(hpDmg * 2);\n    }\n\n    if(!opts.ignoreDepend && buffStage===\'final\' && source.status && source.status.dependStacks>0){\n      if(!source._dependUnleash){\n        appendLog(`${source.name} 的“依赖”触发：造成真实伤害`);\n        source._dependUnleash = true;\n      }\n      trueDamage = true;\n    }\n  }\n\n  // 掩体：远程（距离>1）才被掩体免疫\n  if(source && !trueDamage){\n    if(isCoverCell(u.r, u.c) && mdist(source, u) > 1 && !opts.ignoreCover){\n      appendLog(`${u.name} 处于掩体内，抵御了远距离伤害`);\n      return;\n    }\n  }\n  // 力挽狂澜减伤\n  if(u.id===\'haz\' && u._comeback && !trueDamage){\n    hpDmg = Math.round(hpDmg * 0.9);\n    spDmg = Math.round(spDmg * 0.9);\n  }\n\n  // 姿态减伤（优先于 Tusk 固有护甲）\n  if(!trueDamage && u._stanceType && u._stanceTurns>0 && u._stanceDmgRed>0){\n    hpDmg = Math.round(hpDmg * (1 - u._stanceDmgRed));\n    spDmg = Math.round(spDmg * (1 - u._stanceDmgRed));\n  } else {\n    // Tusk 固有“骨墙”（若未进入姿态）\n    if(!trueDamage && u.id===\'tusk\' && !opts.ignoreTuskWall){\n      hpDmg = Math.round(hpDmg * 0.7);\n      spDmg = Math.round(spDmg * 0.7);\n    }\n  }\n\n  // Tusk 替 Haz 承伤\n  if(!trueDamage && u.id===\'haz\'){\n    const tusk = units[\'tusk\'];\n    if(tusk && tusk.hp>0){\n      const redHp = Math.round(hpDmg * 0.5);\n      const redSp = Math.round(spDmg * 0.5);\n      appendLog(`Tusk 家人的守护：替 Haz 承受伤害（-50%）`);\n      tusk.tuskRageStacks = (tusk.tuskRageStacks||0) + 1;\n      damageUnit(\'tusk\', redHp, redSp, `（转移自 Haz）${reason}`, sourceId, {...opts, _redirected:true});\n      return;\n    }\n  }\n\n  if(!trueDamage && u.id===\'haz\' && u.chainShieldTurns>0){\n    hpDmg = Math.round(hpDmg * 0.6);\n    spDmg = Math.round(spDmg * 0.6);\n  }\n  if(!trueDamage && u.passives.includes(\'toughBody\') && !opts.ignoreToughBody){\n    hpDmg = Math.round(hpDmg * 0.75);\n  }\n\n  if(u._spCrashVuln && (hpDmg>0 || spDmg>0)){\n    hpDmg = Math.round(hpDmg * 2);\n    spDmg = Math.round(spDmg * 2);\n    appendLog(`${u.name} 因 SP 崩溃眩晕承受双倍伤害！`);\n  }\n\n  const prevHp = u.hp;\n  const finalHp = Math.max(0, hpDmg);\n  const finalSp = Math.max(0, spDmg);\n\n  u.hp = Math.max(0, u.hp - finalHp);\n  u.sp = Math.max(0, u.sp - finalSp);\n  const died = prevHp > 0 && u.hp <= 0;\n\n  const totalImpact = finalHp + finalSp;\n  const heavyHit = trueDamage || totalImpact >= 40 || finalHp >= Math.max(18, Math.round(u.maxHp * 0.3));\n  appendLog(`${reason} (-${finalHp} HP, -${finalSp} SP)`);\n  cameraShake(heavyHit ? \'heavy\' : \'normal\');\n  const skillFxKey = opts.skillFx || (opts.skillName && source ? `${source.id}:${opts.skillName}` : null);\n  if(skillFxKey){\n    const fxCtx = Object.assign({}, opts.skillFxCtx || {});\n    if(fxCtx.attacker === undefined) fxCtx.attacker = source;\n    if(fxCtx.target === undefined) fxCtx.target = u;\n    if(fxCtx.cell === undefined && opts.fxCell) fxCtx.cell = opts.fxCell;\n    if(fxCtx.point === undefined && opts.fxPoint) fxCtx.point = opts.fxPoint;\n    if(opts.skillFxAngle !== undefined) fxCtx.angle = opts.skillFxAngle;\n    fxCtx.trueDamage = trueDamage;\n    fxCtx.heavy = heavyHit;\n    showSkillFx(skillFxKey, fxCtx);\n  } else {\n    showAttackFx({attacker: source, target: u, trueDamage, heavy: heavyHit});\n  }\n  showDamageFloat(u, finalHp, finalSp);\n  pulseCell(u.r, u.c);\n  if(died){ showDeathFx(u); }\n\n  // 锁链缠绕 反击（Haz）\n  if(sourceId){\n    const src = units[sourceId];\n    if(src && u.chainShieldTurns>0 && u.chainShieldRetaliate>0){\n      u.chainShieldRetaliate = 0;\n      applySpDamage(src, 10, {sourceId: u.id, reason:`锁链缠绕反击：${src.name} SP -{delta}`});\n      showSkillFx(\'haz:锁链缠绕·反击\',{target:src});\n    }\n  }\n\n  // 反伤姿态：反弹部分HP伤害\n  if(sourceId && u._stanceType===\'retaliate\' && u._stanceTurns>0 && u._reflectPct>0 && !opts._reflected){\n    const refl = Math.max(0, Math.round(finalHp * u._reflectPct));\n    if(refl>0){\n      const src = units[sourceId];\n      if(src && src.hp>0){\n        appendLog(`${u.name} 的反伤姿态：反弹 ${refl} 伤害给 ${src.name}`);\n        damageUnit(src.id, refl, 0, `反伤姿态反弹自 ${u.name}`, u.id, {...opts, _reflected:true, ignoreCover:true, ignoreToughBody:true});\n      }\n    }\n  }\n\n  handleSpCrashIfNeeded(u);\n  checkHazComebackStatus();\n\n  renderAll();\n}\n\n// —— 公用 FX —— \nfunction showTrail(r1,c1,r2,c2,{thickness=6,color=null}={}){\n  ensureFxLayer();\n  const p1=getCellCenter(r1,c1), p2=getCellCenter(r2,c2);\n  const dx=p2.x-p1.x, dy=p2.y-p1.y;\n  const len=Math.hypot(dx,dy);\n  const ang=Math.atan2(dy,dx)*180/Math.PI;\n  const trail=makeEl(\'fx-trail\');\n  if(color){ trail.style.background=color; }\n  trail.style.left=`${p1.x}px`;\n  trail.style.top =`${p1.y}px`;\n  trail.style.width=`${thickness}px`;\n  trail.style.transformOrigin=\'0 0\';\n  trail.style.transform=`translate(0,-${Math.max(1, Math.floor(thickness/2))}px) rotate(${ang}deg) scaleY(${len/thickness})`;\n  fxLayer.appendChild(trail);\n  onAnimEndRemove(trail, 260);\n}\n\n// —— 玩家/敌方技能 —— \nfunction playerGunExec(u, desc){\n  const dir = desc && desc.dir ? desc.dir : u.facing;\n  setUnitFacing(u, dir);\n  const muzzle = forwardCellAt(u, dir, 1) || {r:u.r,c:u.c};\n  cameraFocusOnCell(muzzle.r, muzzle.c);\n  const line = forwardLineAt(u,dir);\n  for(const cell of line){\n    const tu = getUnitAt(cell.r,cell.c);\n    showTrail(muzzle.r, muzzle.c, cell.r, cell.c);\n    if(tu && tu.hp>0 && tu.side !== u.side){\n      damageUnit(tu.id,10,5,`${u.name} 的 枪击 命中 ${tu.name}`, u.id,{skillFx:`${u.id}:枪击`});\n      u.dmgDone += 10;\n    }\n  }\n  unitActed(u);\n}\nfunction adoraDagger(u,target){\n  if(!target || target.side===u.side){ appendLog(\'短匕轻挥 目标无效\'); return; }\n  const dmg = calcOutgoingDamage(u,10,target,\'短匕轻挥\');\n  cameraFocusOnCell(target.r, target.c);\n  damageUnit(target.id, dmg, 5, `${u.name} 用 短匕轻挥 攻击 ${target.name}`, u.id,{skillFx:\'adora:短匕轻挥\'});\n  u.dmgDone += dmg; unitActed(u);\n}\nfunction adoraPanicMove(u, payload){\n  const dest = payload && payload.moveTo; if(!dest){ appendLog(\'无效的目的地\'); return; }\n  cameraFocusOnCell(dest.r, dest.c); showTrail(u.r,u.c,dest.r,dest.c);\n  if(dest.r !== u.r || dest.c !== u.c){\n    const dir = cardinalDirFromDelta(dest.r - u.r, dest.c - u.c);\n    setUnitFacing(u, dir);\n  }\n  u.r=dest.r; u.c=dest.c; pulseCell(u.r,u.c);\n  showSkillFx(\'adora:呀！你不要靠近我呀！！\',{target:u});\n  for(const d of Object.keys(DIRS)){\n    const cell = forwardCellAt(u,d,1); if(!cell) continue;\n    const t = getUnitAt(cell.r,cell.c);\n    if(t && t.side!==u.side && t.hp>0 && t.hp <= t.maxHp/2){ appendLog(`${u.name} 追击残血！`); adoraDagger(u,t); break; }\n  }\n  unitActed(u);\n}\nfunction adoraZap(u,target){\n  if(!target || target.side===u.side){ appendLog(\'电击装置 目标无效\'); return; }\n  cameraFocusOnCell(target.r, target.c);\n  damageUnit(target.id,10,15,`${u.name} 自制粉色迷你电击装置 命中 ${target.name}`, u.id,{skillFx:\'adora:自制粉色迷你电击装置\'});\n  applyStunOrStack(target, 1, {reason:\'电击装置\'});\n  addStatusStacks(target,\'paralyzed\',1,{label:\'恐惧\', type:\'debuff\'});\n  appendLog(`${target.name} 下回合 -1 步`);\n  u.dmgDone += 10; unitActed(u);\n}\nfunction adoraCheer(u, aim){\n  const t = getUnitAt(aim.r, aim.c);\n  if(!t || t.side!==u.side){ appendLog(\'加油哇！ 目标无效\'); return; }\n  if(t.status.jixueStacks>0){ appendLog(`${t.name} 已经处于“鸡血”状态`); return; }\n  updateStatusStacks(t,\'jixueStacks\',1,{label:\'鸡血\', type:\'buff\'});\n  pulseCell(t.r,t.c);\n  showSkillFx(\'adora:加油哇！\',{target:t});\n  appendLog(`${u.name} 对 ${t.name} 使用 加油哇！：赋予 1 层“鸡血”`);\n  unitActed(u);\n}\nfunction darioClaw(u,target){\n  if(!target || target.side===u.side){ appendLog(\'机械爪击 目标无效\'); return; }\n  const dmg = calcOutgoingDamage(u,15,target,\'机械爪击\');\n  cameraFocusOnCell(target.r, target.c);\n  damageUnit(target.id, dmg, 0, `${u.name} 发动 机械爪击 ${target.name}`, u.id,{skillFx:\'dario:机械爪击\'});\n  u.dmgDone += dmg; unitActed(u);\n}\nfunction darioSwiftMove(u, payload){\n  const dest = payload && payload.moveTo; if(!dest){ appendLog(\'无效的目的地\'); return; }\n  cameraFocusOnCell(dest.r, dest.c); showTrail(u.r,u.c,dest.r,dest.c);\n  if(dest.r !== u.r || dest.c !== u.c){\n    const dir = cardinalDirFromDelta(dest.r - u.r, dest.c - u.c);\n    setUnitFacing(u, dir);\n  }\n  u.r=dest.r; u.c=dest.c; pulseCell(u.r,u.c);\n  showSkillFx(\'dario:迅捷步伐\',{target:u});\n  const enemies = Object.values(units).filter(x=>x.side!==u.side && x.hp>0);\n  if(enemies.length){\n    let target=null, best=1e9;\n    for(const e of enemies){ const d=mdist(u,e); if(d<best){best=d; target=e;} }\n    const reduced = applySpDamage(target, 5, {sourceId:u.id});\n    appendLog(`${target.name} SP -${reduced}（迅捷步伐）`);\n    showSkillFx(\'dario:迅捷步伐\',{target:target});\n  }\n  unitActed(u);\n}\nfunction darioPull(u, targetOrDesc){\n  let target = null, usedDir = null;\n  if(targetOrDesc && targetOrDesc.id){ target = targetOrDesc; usedDir = cardinalDirFromDelta(target.r - u.r, target.c - u.c); }\n  else if(targetOrDesc && targetOrDesc.dir){ usedDir = targetOrDesc.dir; const line = forwardLineAt(u, usedDir); for(const cell of line){ const tu=getUnitAt(cell.r,cell.c); if(tu && tu.hp>0 && tu.side!==u.side){ target=tu; break; } } }\n  if(!target){ appendLog(\'拿来吧你！ 未找到可拉拽目标\'); return; }\n  cameraFocusOnCell(target.r, target.c);\n  if(target.pullImmune){ appendLog(`${target.name} 免疫拉扯（小Boss/Boss），改为冲击效果`); }\n  else {\n    let placement = null;\n    if(usedDir){\n      const line = forwardLineAt(u, usedDir);\n      for(const cell of line){ const occ = getUnitAt(cell.r, cell.c); if(!occ){ placement = cell; break; } }\n    }\n    if(placement){\n      appendLog(`${u.name} 将 ${target.name} 拉到 (${placement.r}, ${placement.c})`);\n      showTrail(target.r, target.c, placement.r, placement.c);\n      target.r = placement.r; target.c = placement.c; pulseCell(target.r, target.c);\n    } else {\n      appendLog(\'前方无空位，改为直接造成冲击效果\');\n    }\n  }\n  const dmg = calcOutgoingDamage(u,20,target,\'拿来吧你！\');\n  damageUnit(target.id, dmg, 0, `${u.name} 的 拿来吧你！ 命中 ${target.name}`, u.id,{skillFx:\'dario:拿来吧你！\'});\n  applyStunOrStack(target, 1, {reason:\'拉扯冲击\'});\n  const reduced = applySpDamage(target, 15, {sourceId: u.id});\n  appendLog(`${target.name} SP -${reduced}`);\n  u.dmgDone += dmg; unitActed(u);\n}\nfunction darioSweetAfterBitter(u){\n  playerBonusStepsNextTurn += 4;\n  appendLog(`${u.name} 使用 先苦后甜：下个玩家回合 +4 步`);\n  showSkillFx(\'dario:先苦后甜\',{target:u});\n  unitActed(u);\n}\nfunction adoraDepend(u, aim){\n  const t = getUnitAt(aim.r, aim.c);\n  if(!t || t.side!==u.side){ appendLog(\'只能靠你了。。 目标无效\'); return; }\n  if(t.status.dependStacks>0){ appendLog(`${t.name} 已经处于“依赖”状态`); return; }\n  damageUnit(u.id, 25, 0, `${u.name} 牺牲自身 25 HP`, null, {trueDamage:true, ignoreJixue:true, ignoreDepend:true, skillFx:\'adora:只能靠你了。。\', skillFxCtx:{target:u}});\n  updateStatusStacks(t,\'dependStacks\',1,{label:\'依赖\', type:\'buff\'});\n  pulseCell(t.r,t.c);\n  showSkillFx(\'adora:只能靠你了。。\',{target:t});\n  appendLog(`${u.name} 对 ${t.name} 施加“依赖”：下一次攻击造成真实伤害并清空自身SP`);\n  unitActed(u);\n}\nfunction karmaObeyMove(u, payload){\n  const dest = payload && payload.moveTo; if(!dest){ appendLog(\'无效的目的地\'); return; }\n  cameraFocusOnCell(dest.r, dest.c); showTrail(u.r,u.c,dest.r,dest.c);\n  if(dest.r !== u.r || dest.c !== u.c){\n    const dir = cardinalDirFromDelta(dest.r - u.r, dest.c - u.c);\n    setUnitFacing(u, dir);\n  }\n  u.r = dest.r; u.c = dest.c; pulseCell(u.r,u.c);\n  showSkillFx(\'karma:都听你的\',{target:u});\n  if(u.consecAttacks > 0){ appendLog(`${u.name} 的连击被打断（移动）`); u.consecAttacks = 0; }\n  u.sp = Math.min(u.maxSp, u.sp + 5); syncSpBroken(u); showGainFloat(u,0,5);\n  unitActed(u);\n}\nfunction karmaGrip(u,target){\n  if(!target || target.side===u.side){ appendLog(\'嗜血之握 目标无效\'); return; }\n  cameraFocusOnCell(target.r, target.c);\n  let fixed = null;\n  if(target.id===\'haz\') fixed = 75;\n  else if(target.id===\'tusk\' || target.id===\'katz\') fixed = 80;\n  else if(target.id===\'kyn\' || target.id===\'neyla\') fixed = 100;\n  if(fixed!==null){\n    const deal = Math.min(target.hp, fixed);\n    damageUnit(target.id, deal, 0, `${u.name} 嗜血之握 重创 ${target.name}`, u.id, {ignoreToughBody:true, ignoreTuskWall:true, skillFx:\'karma:嗜血之握\'});\n  } else {\n    damageUnit(target.id, target.hp, 0, `${u.name} 嗜血之握 处决 ${target.name}`, u.id, {ignoreToughBody:true, skillFx:\'karma:嗜血之握\'});\n  }\n  unitActed(u);\n}\nfunction unitActed(u){\n  if(!u) return;\n  u.actionsThisTurn = Math.max(0, (u.actionsThisTurn||0)+1);\n\n  let statusNeedsRefresh = false;\n  let requireFullRender = false;\n\n  if(u._jixueActivated){\n    if(u.status){\n      const prev = u.status.jixueStacks || 0;\n      if(prev>0){\n        updateStatusStacks(u,\'jixueStacks\', Math.max(0, prev - 1), {label:\'鸡血\', type:\'buff\'});\n        appendLog(`${u.name} 的“鸡血”消散`);\n        statusNeedsRefresh = true;\n      }\n    }\n    u._jixueActivated = false;\n  }\n\n  if(u._dependUnleash){\n    if(u.status){\n      const prev = u.status.dependStacks || 0;\n      if(prev>0){\n        updateStatusStacks(u,\'dependStacks\', 0, {label:\'依赖\', type:\'buff\'});\n        const beforeSp = u.sp;\n        u.sp = 0;\n        syncSpBroken(u);\n        if(beforeSp>0){\n          appendLog(`${u.name} 的“依赖”消散：SP 清空`);\n          showDamageFloat(u,0,beforeSp);\n        } else {\n          appendLog(`${u.name} 的“依赖”消散：SP 已为 0`);\n        }\n        handleSpCrashIfNeeded(u);\n        requireFullRender = true;\n      }\n    }\n    u._dependUnleash = false;\n  }\n\n  if(requireFullRender){\n    renderAll();\n  } else if(statusNeedsRefresh){\n    renderStatus();\n  }\n}\nfunction karmaPunch(u,target){\n  if(!target || target.side===u.side){ appendLog(\'沙包大的拳头 目标无效\'); return; }\n  const dmg = calcOutgoingDamage(u, 15, target, \'沙包大的拳头\');\n  cameraFocusOnCell(target.r, target.c);\n  damageUnit(target.id, dmg, 0, `${u.name} 出拳 ${target.name}`, u.id,{skillFx:\'karma:沙包大的拳头\'});\n  u.dmgDone += dmg; u.consecAttacks = (u.consecAttacks||0)+1; unitActed(u);\n}\n\n// —— Katz 技能（含新反复鞭尸逻辑） —— \nasync function katz_RepeatedWhip(u, desc){\n  // 反复鞭尸（三步）\n  // 鱼矛成鞭，挥舞前面3格所有敌方单位：10伤害后再15伤害，并恢复5SP；\n  // 按自身SP百分比重复该两段攻击（floor(sp/maxSp*5) 次，1..5），最多5次\n  const dir = (desc && desc.dir) ? desc.dir : u.facing;\n  const cells = range_forward_n(u,3,dir);\n  if(!cells.length){ appendLog(\'反复鞭尸：前路受阻\'); unitActed(u); return; }\n\n  const cycles = Math.max(1, Math.min(5, Math.floor((u.sp / Math.max(1,u.maxSp)) * 5)));\n  let totalHits = 0;\n  for(let cycle=1; cycle<=cycles; cycle++){\n    await telegraphThenImpact(cells);\n    const hitSet1=new Set(); let hits1=0;\n    for(const c of cells){\n      const tu=getUnitAt(c.r,c.c);\n      if(tu && tu.side!==\'enemy\' && !hitSet1.has(tu.id)){\n        damageUnit(tu.id, 10, 0, `${u.name} 反复鞭尸·第${cycle}次 第一鞭 命中 ${tu.name}`, u.id,{skillFx:\'katz:反复鞭尸\'});\n        hitSet1.add(tu.id); hits1++;\n      }\n    }\n    await stageMark(cells);\n    const hitSet2=new Set(); let hits2=0;\n    for(const c of cells){\n      const tu=getUnitAt(c.r,c.c);\n      if(tu && tu.side!==\'enemy\' && !hitSet2.has(tu.id)){\n        damageUnit(tu.id, 15, 0, `${u.name} 反复鞭尸·第${cycle}次 第二鞭 重击 ${tu.name}`, u.id,{skillFx:\'katz:反复鞭尸\'});\n        hitSet2.add(tu.id); hits2++;\n      }\n    }\n    // 每轮 +5SP\n    const beforeSP = u.sp;\n    u.sp = Math.min(u.maxSp, u.sp + 5);\n    syncSpBroken(u);\n    showGainFloat(u,0,u.sp-beforeSP);\n    totalHits += hits1 + hits2;\n  }\n  appendLog(`反复鞭尸 累计命中段数：${totalHits}`);\n  unitActed(u);\n}\nasync function katz_EndSalvo(u, desc){\n  // 终焉礼炮：直线5格，每单位35HP（不受掩体）；常态/压迫均可用\n  const dir = (desc && desc.dir) ? desc.dir : u.facing;\n  const cells = range_forward_n(u,5,dir);\n  await telegraphThenImpact(cells);\n  let hits=0,set=new Set();\n  for(const c of cells){\n    const tu=getUnitAt(c.r,c.c);\n    if(tu && tu.side!==\'enemy\' && !set.has(tu.id)){\n      damageUnit(tu.id, 35, 0, `${u.name} 终焉礼炮 命中 ${tu.name}`, u.id, {ignoreCover:true, skillFx:\'katz:终焉礼炮\'});\n      set.add(tu.id); hits++;\n    }\n  }\n  appendLog(`终焉礼炮 命中 ${hits} 人`);\n  unitActed(u);\n}\n\n// —— 新增技能实现 —— \n// Adora：略懂的医术！（25级，粉色）\nfunction adoraFieldMedic(u, aim){\n  const t = getUnitAt(aim.r, aim.c);\n  if(!t || t.side!==u.side){ appendLog(\'略懂的医术！ 目标无效\'); return; }\n  const hpBefore = t.hp, spBefore = t.sp;\n  t.hp = Math.min(t.maxHp, t.hp + 20);\n  t.sp = Math.min(t.maxSp, t.sp + 15);\n  syncSpBroken(t);\n  const stacks = addStatusStacks(t,\'recoverStacks\',1,{label:\'恢复\', type:\'buff\'});\n  appendLog(`${u.name} 对 ${t.name} 使用 略懂的医术！：+20HP +15SP，并赋予“恢复”(${stacks})`);\n  showGainFloat(t,t.hp-hpBefore,t.sp-spBefore);\n  showSkillFx(\'adora:略懂的医术！\',{target:t});\n  unitActed(u);\n}\n// Karma：深呼吸（25级，白色）\nfunction karmaDeepBreath(u){\n  const hpBefore = u.hp, spBefore = u.sp;\n  u.sp = u.maxSp; syncSpBroken(u);\n  u.hp = Math.min(u.maxHp, u.hp + 10);\n  appendLog(`${u.name} 使用 深呼吸：SP回满，+10HP（被动+10%仅在手牌中未被使用时生效）`);\n  showGainFloat(u,u.hp-hpBefore,u.sp-spBefore);\n  showSkillFx(\'karma:深呼吸\',{target:u});\n  unitActed(u);\n}\n\n// Haz 原有与禁招（多阶段均即时结算）\nasync function haz_HarpoonStab(u, target){\n  if(!target || target.side===u.side){ appendLog(\'鱼叉穿刺 目标无效\'); return; }\n  const cells=[{r:target.r,c:target.c}];\n  await telegraphThenImpact(cells);\n  const dmg = calcOutgoingDamage(u,20,target,\'鱼叉穿刺\');\n  cameraFocusOnCell(target.r, target.c);\n  damageUnit(target.id, dmg, 0, `${u.name} 鱼叉穿刺 命中 ${target.name}`, u.id,{skillFx:\'haz:鱼叉穿刺\'});\n  u.sp = Math.min(u.maxSp, u.sp + 10); syncSpBroken(u); showGainFloat(u,0,10);\n  if(!hazMarkedTargetId){ hazMarkedTargetId = target.id; appendLog(`猎杀标记：${target.name} 被标记，七海对其伤害 +15%`); }\n  if(Math.random() < 0.4){\n    const reduced = applySpDamage(target,5,{sourceId:u.id});\n    appendLog(`${target.name} SP -${reduced}（恐惧）`);\n    addStatusStacks(target,\'paralyzed\',1,{label:\'恐惧\', type:\'debuff\'});\n    appendLog(`${target.name} 下回合 -1 步`);\n    showSkillFx(\'haz:怨念滋生·恐惧\',{target:target});\n  }\n  u.dmgDone += dmg; unitActed(u);\n}\nasync function haz_DeepHunt(u, desc){\n  const dir = desc && desc.dir ? desc.dir : u.facing;\n  const cells = range_forward_n(u,3,dir);\n  await telegraphThenImpact(cells);\n  let target=null;\n  for(const c of cells){ const tu=getUnitAt(c.r,c.c); if(tu && tu.side!==\'enemy\'){ target=tu; break; } }\n  if(!target){ appendLog(\'深海猎杀 未找到目标\'); return; }\n  const dmg = calcOutgoingDamage(u,25,target,\'深海猎杀\');\n  cameraFocusOnCell(target.r, target.c);\n  damageUnit(target.id, dmg, 0, `${u.name} 深海猎杀 命中 ${target.name}`, u.id,{skillFx:\'haz:深海猎杀\'});\n  const front = forwardCellAt(u, dir, 1);\n  if(front && !getUnitAt(front.r, front.c)){ target.r = front.r; target.c = front.c; pulseCell(front.r, front.c); appendLog(`${target.name} 被拉至面前一格`); }\n  const reduced = applySpDamage(target,10,{sourceId:u.id});\n  appendLog(`${target.name} SP -${reduced}`);\n  if(!hazMarkedTargetId){ hazMarkedTargetId = target.id; appendLog(`猎杀标记：${target.name} 被标记，七海对其伤害 +15%`); }\n  u.dmgDone += dmg; unitActed(u);\n}\nasync function haz_GodFork(u, target){\n  if(!target || target.side===u.side){ appendLog(\'猎神之叉 目标无效\'); return; }\n  await telegraphThenImpact([{r:target.r,c:target.c}]);\n  const adj = range_adjacent(target);\n  let dest = null, best=1e9;\n  for(const p of adj){ if(getUnitAt(p.r,p.c)) continue; const d = mdist(u, p); if(d<best){best=d; dest=p;} }\n  if(dest){ u.r=dest.r; u.c=dest.c; pulseCell(u.r,u.c); appendLog(`${u.name} 瞬移至 ${target.name} 身边`); }\n  let dmg = calcOutgoingDamage(u,20,target,\'猎神之叉\');\n  if(Math.random()<0.5){ dmg = Math.round(dmg*2.0); appendLog(\'猎神之叉 暴怒加成 x2.0\'); }\n  cameraFocusOnCell(target.r, target.c);\n  damageUnit(target.id, dmg, 15, `${u.name} 猎神之叉 重击 ${target.name}`, u.id,{skillFx:\'haz:猎神之叉\'});\n  const bleedStacks = Math.max(target.status.bleed||0, 2);\n  updateStatusStacks(target,\'bleed\', bleedStacks,{label:\'流血\', type:\'debuff\'});\n  appendLog(`${target.name} 附加流血（2回合，每回合 -5%最大HP）`);\n  if(!hazMarkedTargetId){ hazMarkedTargetId = target.id; appendLog(`猎杀标记：${target.name} 被标记，七海对其伤害 +15%`); }\n  u.dmgDone += dmg; unitActed(u);\n}\nfunction haz_ChainShield(u){\n  u.chainShieldTurns = 2; u.chainShieldRetaliate = 1;\n  appendLog(`${u.name} 锁链缠绕：2回合内伤害-40%，下次被打反击 10SP`);\n  showSkillFx(\'haz:锁链缠绕\',{target:u});\n  for(const id in units){\n    const v=units[id];\n    if(v.team===\'seven\' && v.hp>0){\n      v.sp = Math.min(v.maxSp, v.sp+5);\n      syncSpBroken(v);\n      showGainFloat(v,0,5);\n      showSkillFx(\'haz:锁链缠绕·增益\',{target:v});\n    }\n  }\n  unitActed(u);\n}\nasync function haz_WhaleFall(u){\n  const cells = range_square_n(u,2);\n  await telegraphThenImpact(cells);\n  const set=new Set(); let hits=0;\n  for(const c of cells){\n    const tu = getUnitAt(c.r,c.c);\n    if(tu && tu.side!==\'enemy\' && !set.has(tu.id)){\n      damageUnit(tu.id, 50, 20, `${u.name} 鲸落 轰击 ${tu.name}`, u.id, {ignoreCover:true, skillFx:\'haz:鲸落\'});\n      addStatusStacks(tu,\'paralyzed\',1,{label:\'恐惧\', type:\'debuff\'});\n      set.add(tu.id); hits++;\n    }\n  }\n  appendLog(`鲸落 命中 ${hits} 个单位`);\n  unitActed(u);\n}\nasync function haz_PayThePrice(u, desc){\n  const dir = desc && desc.dir ? desc.dir : u.facing;\n\n  // 段1：前刺（前3）\n  const L1 = range_forward_n(u,3,dir);\n  await telegraphThenImpact(L1);\n  let h1=0;\n  for(const c of L1){ const tu=getUnitAt(c.r,c.c); showTrail(u.r,u.c,c.r,c.c); if(tu && tu.side!==\'enemy\'){ damageUnit(tu.id,15,0,`${u.name} 付出代价·前刺 命中 ${tu.name}`, u.id,{skillFx:\'haz:付出代价\'}); h1++; } }\n  await stageMark(L1);\n\n  // 段2：穿刺（前4）\n  const L2 = range_forward_n(u,4,dir);\n  await telegraphThenImpact(L2);\n  let h2=0;\n  for(const c of L2){ const tu=getUnitAt(c.r,c.c); showTrail(u.r,u.c,c.r,c.c); if(tu && tu.side!==\'enemy\'){ damageUnit(tu.id,15,5,`${u.name} 付出代价·穿刺 命中 ${tu.name}`, u.id,{skillFx:\'haz:付出代价\'}); h2++; } }\n  await stageMark(L2);\n\n  // 段3：横斩（横3x前2）\n  const R = forwardRectCentered(u, dir, 3, 2);\n  await telegraphThenImpact(R);\n  let h3=0; const seen=new Set();\n  for(const c of R){\n    const tu=getUnitAt(c.r,c.c);\n    if(tu && tu.side!==\'enemy\' && !seen.has(tu.id)){\n      damageUnit(tu.id,15,0,`${u.name} 付出代价·横斩 命中 ${tu.name}`, u.id,{skillFx:\'haz:付出代价\'});\n      updateStatusStacks(tu,\'hazBleedTurns\',2,{label:\'Haz流血\', type:\'debuff\'});\n      appendLog(`${tu.name} 附加 Haz流血(2)`); seen.add(tu.id); h3++;\n    }\n  }\n  appendLog(`付出代价：前刺${h1}/穿刺${h2}/横斩${h3}`);\n  unitActed(u);\n}\nasync function haz_ForkOfHatred(u, desc){\n  const dir = desc && desc.dir ? desc.dir : u.facing;\n\n  // 阶段1：横斩（横3x前2）\n  const R = forwardRectCentered(u, dir, 3, 2);\n  await telegraphThenImpact(R);\n  let h1=0; const seen1=new Set();\n  for(const c of R){\n    const tu=getUnitAt(c.r,c.c);\n    if(tu && tu.side!==\'enemy\' && !seen1.has(tu.id)){\n      damageUnit(tu.id,15,10,`${u.name} 仇恨之叉·横斩 命中 ${tu.name}`, u.id,{skillFx:\'haz:仇恨之叉\'});\n      seen1.add(tu.id); h1++;\n    }\n  }\n  await stageMark(R);\n\n  // 阶段2：自身5x5重砸（不受掩体）\n  const AOE = range_square_n(u,2);\n  await telegraphThenImpact(AOE);\n  let h2=0; const seen2=new Set();\n  for(const c of AOE){\n    const tu=getUnitAt(c.r,c.c);\n    if(tu && tu.side!==\'enemy\' && !seen2.has(tu.id)){\n      damageUnit(tu.id,20,0,`${u.name} 仇恨之叉·重砸 命中 ${tu.name}`, u.id, {ignoreCover:true, skillFx:\'haz:仇恨之叉\'});\n      updateStatusStacks(tu,\'hazBleedTurns\',2,{label:\'Haz流血\', type:\'debuff\'});\n      appendLog(`${tu.name} 附加 Haz流血(2)`);\n      seen2.add(tu.id); h2++;\n    }\n  }\n  appendLog(`仇恨之叉：横斩命中 ${h1}，重砸命中 ${h2}`);\n  unitActed(u);\n}\n\n// Katz\nasync function katz_Thrust(u,target){\n  if(!target || target.side===u.side){ appendLog(\'矛刺 目标无效\'); return; }\n  await telegraphThenImpact([{r:target.r,c:target.c}]);\n  let dmg = calcOutgoingDamage(u,20,target,\'矛刺\');\n  cameraFocusOnCell(target.r,target.c);\n  damageUnit(target.id, dmg, 0, `${u.name} 矛刺 命中 ${target.name}`, u.id,{skillFx:\'katz:矛刺\'});\n  u.sp = Math.min(u.maxSp, u.sp+5); syncSpBroken(u); showGainFloat(u,0,5);\n  u.dmgDone += dmg; unitActed(u);\n}\nasync function katz_ChainWhip(u,desc){\n  const dir = desc && desc.dir ? desc.dir : u.facing;\n  const cells = range_forward_n(u,3,dir);\n  await telegraphThenImpact(cells);\n  let hits=0, set=new Set();\n  for(const c of cells){\n    const tu=getUnitAt(c.r,c.c);\n    if(tu && tu.side!==\'enemy\' && !set.has(tu.id)){\n      damageUnit(tu.id,25,0,`${u.name} 链式鞭击 命中 ${tu.name}`, u.id,{skillFx:\'katz:链式鞭击\'});\n      addStatusStacks(tu,\'paralyzed\',1,{label:\'恐惧\', type:\'debuff\'});\n      set.add(tu.id); hits++;\n    }\n  }\n  appendLog(`链式鞭击 命中 ${hits} 人`);\n  unitActed(u);\n}\nasync function katz_MustErase(u, desc){\n  const dir = desc && desc.dir ? desc.dir : u.facing;\n  const cells = range_forward_n(u,3,dir);\n  await telegraphThenImpact(cells);\n  const cycleTimes = Math.max(1, Math.min(5, Math.floor((u.sp/u.maxSp)*5)));\n  for(let cycle=1; cycle<=cycleTimes; cycle++){\n    const dmg = cycle===1?20:30;\n    let set=new Set(), hits=0;\n    for(const c of cells){\n      const tu=getUnitAt(c.r,c.c);\n      if(tu && tu.side!==\'enemy\' && !set.has(tu.id)){\n        damageUnit(tu.id, dmg, 0, `${u.name} 必须抹杀一切.. 第${cycle}段 命中 ${tu.name}`, u.id,{skillFx:\'katz:必须抹杀一切。。\'});\n        set.add(tu.id); hits++;\n      }\n    }\n    if(hits>0){\n      u.hp = Math.max(1, u.hp - 5); showDamageFloat(u,5,0);\n      u.sp = Math.min(u.maxSp, u.sp + 5); syncSpBroken(u); showGainFloat(u,0,5);\n      await stageMark(cells);\n    }\n  }\n  unitActed(u);\n}\n\n// Tusk\nasync function tusk_ShieldBash(u,target){\n  if(!target || target.side===u.side){ appendLog(\'骨盾猛击 目标无效\'); return; }\n  await telegraphThenImpact([{r:target.r,c:target.c}]);\n  const dmg = calcOutgoingDamage(u,10,target,\'骨盾猛击\');\n  cameraFocusOnCell(target.r,target.c);\n  damageUnit(target.id, dmg, 0, `${u.name} 骨盾猛击 ${target.name}`, u.id,{skillFx:\'tusk:骨盾猛击\'});\n  const dir = cardinalDirFromDelta(target.r-u.r, target.c-u.c);\n  const back = forwardCellAt(target, dir, 1);\n  if(back && !getUnitAt(back.r, back.c)){ target.r=back.r; target.c=back.c; pulseCell(back.r,back.c); appendLog(`${target.name} 被击退一格`); }\n  u.dmgDone += dmg; unitActed(u);\n}\nasync function tusk_DeepRoar(u){\n  const cells = range_square_n(u,1);\n  await telegraphThenImpact(cells);\n  const set=new Set(); let hits=0;\n  for(const c of cells){\n    const tu=getUnitAt(c.r,c.c);\n    if(tu && tu.side!==\'enemy\' && !set.has(tu.id)){\n      const reduced = applySpDamage(tu, 20, {sourceId:u.id});\n      appendLog(`${tu.name} 因咆哮 SP -${reduced}`);\n      showSkillFx(\'tusk:来自深海的咆哮\',{target:tu});\n      set.add(tu.id); hits++;\n    }\n  }\n  showSkillFx(\'tusk:来自深海的咆哮\',{target:u});\n  appendLog(`来自深海的咆哮 命中 ${hits} 人`);\n  unitActed(u);\n}\nfunction enterStance(u, type, turns, {dmgReduction=0, spPerTurn=0, reflectPct=0}={}){\n  u._stanceType = type;\n  u._stanceTurns = turns;\n  u._stanceDmgRed = Math.max(0, Math.min(0.9, dmgReduction));\n  u._stanceSpPerTurn = Math.max(0, spPerTurn|0);\n  u._reflectPct = Math.max(0, Math.min(0.9, reflectPct));\n  appendLog(`${u.name} 进入${type===\'defense\'?\'防御姿态\':\'反伤姿态\'}（${turns}回合）`);\n}\nfunction clearStance(u){\n  if(u._stanceType){\n    appendLog(`${u.name} 的${u._stanceType===\'defense\'?\'防御姿态\':\'反伤姿态\'} 结束`);\n  }\n  u._stanceType=null; u._stanceTurns=0; u._stanceDmgRed=0; u._stanceSpPerTurn=0; u._reflectPct=0;\n}\nfunction tusk_WarFortress(u){\n  // 防御姿态：减伤50%，每回合+10SP，3回合；期间无法移动\n  enterStance(u, \'defense\', 3, {dmgReduction:0.5, spPerTurn:10});\n  showSkillFx(\'tusk:战争堡垒\',{target:u});\n  unitActed(u);\n}\nfunction tusk_RetaliateGuard(u){\n  // 反伤姿态：减伤40%，每回合+10SP，反弹30%所受HP伤害，3回合；期间无法移动\n  enterStance(u, \'retaliate\', 3, {dmgReduction:0.4, spPerTurn:10, reflectPct:0.3});\n  showSkillFx(\'tusk:拼尽全力保卫队长\',{target:u});\n  unitActed(u);\n}\nasync function tusk_BullCharge(u, desc){\n  // 牛鲨冲撞：朝一个方向冲锋至多3格，撞到第一个敌人时造成20伤并击退1格；若未撞到人则移动到终点\n  const dir = (desc && desc.dir) ? desc.dir : u.facing;\n  const path = range_forward_n(u,3,dir);\n  if(!path.length){ appendLog(\'牛鲨冲撞：前路受阻\'); unitActed(u); return; }\n  await telegraphThenImpact(path);\n  let lastFree = null;\n  let hitTarget = null;\n  for(const step of path){\n    const occ = getUnitAt(step.r, step.c);\n    if(occ && occ.side!==\'enemy\'){ hitTarget = occ; break; }\n    if(!occ) lastFree = step;\n    else break;\n  }\n  if(hitTarget){\n    if(lastFree){ showTrail(u.r,u.c,lastFree.r,lastFree.c); u.r=lastFree.r; u.c=lastFree.c; pulseCell(u.r,u.c); }\n    const dmg = calcOutgoingDamage(u,20,hitTarget,\'牛鲨冲撞\');\n    cameraFocusOnCell(hitTarget.r, hitTarget.c);\n    damageUnit(hitTarget.id, dmg, 0, `${u.name} 牛鲨冲撞 命中并撞击 ${hitTarget.name}`, u.id,{skillFx:\'tusk:牛鲨冲撞\'});\n    const knockDir = cardinalDirFromDelta(hitTarget.r - u.r, hitTarget.c - u.c);\n    const back = forwardCellAt(hitTarget, knockDir, 1);\n    if(back && !getUnitAt(back.r, back.c)){ hitTarget.r=back.r; hitTarget.c=back.c; pulseCell(back.r, back.c); appendLog(`${hitTarget.name} 被撞退一格`); }\n  } else if(lastFree){\n    showTrail(u.r,u.c,lastFree.r,lastFree.c);\n    u.r=lastFree.r; u.c=lastFree.c; pulseCell(u.r,u.c);\n    appendLog(`${u.name} 牛鲨冲撞：无人命中，移动至终点`);\n  } else {\n    appendLog(\'牛鲨冲撞：无法前进\');\n  }\n  unitActed(u);\n}\n\n// Neyla\nasync function neyla_SwiftShot(u, targetOrAim){\n  let tu = null;\n  if(targetOrAim){\n    if(targetOrAim.id) tu = targetOrAim;\n    else if(typeof targetOrAim.r===\'number\' && typeof targetOrAim.c===\'number\') tu = getUnitAt(targetOrAim.r, targetOrAim.c);\n  }\n  if(!tu || tu.side===u.side){ appendLog(\'迅捷射击 未命中\'); unitActed(u); return; }\n  const dist = mdist(u, tu);\n  if(dist > 4){ appendLog(`${u.name} 迅捷射击 失败：目标超出射程（≤4）`); unitActed(u); return; }\n  await telegraphThenImpact([{r:tu.r,c:tu.c}]);\n  let base=15;\n  if((u.actionsThisTurn||0)===0) base = Math.round(base*1.5);\n  if(tu.hp <= tu.maxHp/2) base = base*2;\n  const dmg = calcOutgoingDamage(u,base,tu,\'迅捷射击\');\n  cameraFocusOnCell(tu.r, tu.c);\n  damageUnit(tu.id, dmg, 5, `${u.name} 迅捷射击 命中 ${tu.name}`, u.id,{skillFx:\'neyla:迅捷射击\'});\n  unitActed(u);\n}\nasync function neyla_PierceSnipe(u, desc){\n  const dir = desc && desc.dir ? desc.dir : u.facing;\n  const line = range_forward_n(u,6,dir);\n  await telegraphThenImpact(line);\n  let hits=0, set=new Set();\n  for(const c of line){\n    const tu=getUnitAt(c.r,c.c);\n    if(tu && tu.side!==\'enemy\' && !set.has(tu.id)){\n      damageUnit(tu.id,30,0,`${u.name} 穿刺狙击 命中 ${tu.name}`, u.id,{skillFx:\'neyla:穿刺狙击\'});\n      const bleedNext = Math.max(tu.status.bleed||0, 2);\n      updateStatusStacks(tu,\'bleed\', bleedNext,{label:\'流血\', type:\'debuff\'});\n      set.add(tu.id); hits++;\n    }\n  }\n  appendLog(`穿刺狙击 命中 ${hits} 人`);\n  unitActed(u);\n}\nasync function neyla_EndShadow(u, aim){\n  const tu = getUnitAt(aim.r, aim.c);\n  if(!tu || tu.side===\'enemy\') { appendLog(\'终末之影 未命中\'); unitActed(u); return; }\n  await telegraphThenImpact([{r:tu.r,c:tu.c}]);\n  cameraFocusOnCell(tu.r, tu.c);\n  damageUnit(tu.id, 50, 20, `${u.name} 终末之影 命中 ${tu.name}`, u.id,{skillFx:\'neyla:终末之影\'});\n  unitActed(u);\n}\n// Neyla：双钩牵制（2步，红，前3格内优先最近，单体）\nasync function neyla_DoubleHook(u, desc){\n  const dir = (desc && desc.dir) ? desc.dir : u.facing;\n  const cells = range_forward_n(u,3,dir);\n  await telegraphThenImpact(cells);\n  let target=null;\n  for(const c of cells){ const tu=getUnitAt(c.r,c.c); if(tu && tu.side!==\'enemy\'){ target=tu; break; } }\n  if(!target){ appendLog(\'双钩牵制 未命中\'); unitActed(u); return; }\n  // 拉近一格\n  const backDir = cardinalDirFromDelta(u.r - target.r, u.c - target.c);\n  const stepCell = forwardCellAt(target, backDir, 1);\n  if(stepCell && !getUnitAt(stepCell.r, stepCell.c)){\n    showTrail(target.r,target.c, stepCell.r, stepCell.c);\n    target.r = stepCell.r; target.c = stepCell.c; pulseCell(target.r,target.c);\n    appendLog(`${target.name} 被双钩拉近一格`);\n  }\n  addStatusStacks(target,\'paralyzed\',1,{label:\'恐惧\', type:\'debuff\'});\n  appendLog(`${target.name} 因双钩牵制：下回合 -1 步`);\n  const dmg = calcOutgoingDamage(u,15,target,\'双钩牵制\');\n  damageUnit(target.id, dmg, 0, `${u.name} 双钩牵制 命中 ${target.name}`, u.id,{skillFx:\'neyla:双钩牵制\'});\n  showSkillFx(\'neyla:双钩牵制\',{target:target});\n  u.dmgDone += dmg; unitActed(u);\n}\n\nasync function neyla_ExecuteHarpoons(u, desc){\n  const dir = (desc && desc.dir) ? desc.dir : u.facing;\n  const line = range_line(u, dir);\n  if(line.length===0){ appendLog(\'执行……：前方没有可以射击的目标\'); unitActed(u); return; }\n  await telegraphThenImpact(line);\n  const targets=[]; const seen=new Set();\n  for(const cell of line){\n    const tu = getUnitAt(cell.r, cell.c);\n    if(tu && tu.side!==\'enemy\' && !seen.has(tu.id)){\n      targets.push(tu);\n      seen.add(tu.id);\n    }\n  }\n  if(targets.length>0){ cameraFocusOnCell(targets[0].r, targets[0].c); }\n  const applySelfCost = (hpCost, spCost, stageLabel)=>{\n    let lostHp = 0;\n    if(hpCost>0 && u.hp>0){\n      const before = u.hp;\n      u.hp = Math.max(0, u.hp - hpCost);\n      lostHp = before - u.hp;\n      if(lostHp>0){\n        appendLog(`${u.name} ${stageLabel} 反噬：HP -${lostHp}`);\n        showDamageFloat(u, lostHp, 0);\n        pulseCell(u.r, u.c);\n        if(before>0 && u.hp<=0){ showDeathFx(u); }\n      }\n    }\n    if(spCost>0){\n      applySpDamage(u, spCost, {reason:`${u.name} ${stageLabel} 反噬：SP -{delta}`});\n    }\n    if(lostHp>0){ renderAll(); }\n    return {lostHp};\n  };\n\n  let firstHits = 0;\n  for(const target of targets){\n    if(target.hp<=0) continue;\n    const dmg = calcOutgoingDamage(u,20,target,\'执行……·第一枪\');\n    damageUnit(target.id, dmg, 0, `${u.name} 执行……·第一枪 命中 ${target.name}`, u.id,{skillFx:\'neyla:执行……\'});\n    u.dmgDone += dmg;\n    firstHits++;\n  }\n  if(firstHits>0){ appendLog(`执行……·第一枪 命中 ${firstHits} 人`); }\n  else { appendLog(\'执行……·第一枪 未命中任何目标\'); }\n  applySelfCost(15, 0, \'第一枪\');\n  await stageMark(line);\n  if(u.hp<=0){ unitActed(u); return; }\n  await sleep(180);\n\n  let secondHits = 0; let executeCount = 0;\n  for(const target of targets){\n    if(target.hp<=0) continue;\n    const executeThreshold = Math.ceil(target.maxHp * 0.15);\n    if(target.hp <= executeThreshold){\n      const lethal = target.hp;\n      damageUnit(target.id, lethal, 0, `${u.name} 执行……·第二枪 处决 ${target.name}`, u.id,{skillFx:\'neyla:执行……\', trueDamage:true, ignoreCover:true, ignoreToughBody:true});\n      u.dmgDone += lethal;\n      executeCount++;\n      secondHits++;\n    } else {\n      const dmg = calcOutgoingDamage(u,20,target,\'执行……·第二枪\');\n      damageUnit(target.id, dmg, 0, `${u.name} 执行……·第二枪 命中 ${target.name}`, u.id,{skillFx:\'neyla:执行……\'});\n      u.dmgDone += dmg;\n      secondHits++;\n    }\n  }\n  if(secondHits>0){\n    appendLog(`执行……·第二枪 命中 ${secondHits} 人${executeCount>0 ? `，处决 ${executeCount}` : \'\'}`);\n  } else {\n    appendLog(\'执行……·第二枪 未命中任何目标\');\n  }\n  applySelfCost(15, 40, \'第二枪\');\n  unitActed(u);\n}\n\n// —— Kyn —— \nfunction kynReturnToHaz(u){\n  const haz = units[\'haz\'];\n  if(!haz || haz.hp<=0){ appendLog(\'迅影返身：Haz 已不在场，无法回归\'); return; }\n  const adj = range_adjacent(haz).filter(p=>!getUnitAt(p.r,p.c));\n  if(adj.length===0){ appendLog(\'迅影返身：Haz 身旁无空位\'); return; }\n  let best=adj[0], bestD=mdist(u,adj[0]);\n  for(const p of adj){ const d=mdist(u,p); if(d<bestD){ best=p; bestD=d; } }\n  u.r = best.r; u.c = best.c; pulseCell(u.r,u.c);\n  appendLog(`${u.name} 迅影返身：回归队长身侧`);\n}\nasync function kyn_ShadowDash(u, target){\n  if(!target || target.side===u.side){ appendLog(\'迅影突刺 目标无效\'); return; }\n  await telegraphThenImpact([{r:target.r,c:target.c}]);\n  const adj = range_adjacent(target).filter(p=>!getUnitAt(p.r,p.c));\n  if(adj.length){ const p=adj[0]; u.r=p.r; u.c=p.c; pulseCell(u.r,u.c); }\n  const thresh = Math.ceil(target.maxHp*0.25);\n  let executed = false;\n\n  if(target.hp<=thresh){\n    damageUnit(target.id, target.hp, 0, `${u.name} 迅影突刺 处决 ${target.name}`, u.id,{skillFx:\'kyn:迅影突刺\'});\n    executed = true;\n  } else {\n    const before = target.hp;\n    damageUnit(target.id, 20, 0, `${u.name} 迅影突刺 命中 ${target.name}`, u.id,{skillFx:\'kyn:迅影突刺\'});\n    if(before>0 && target.hp<=0) executed = true;\n  }\n  if(u.passives.includes(\'kynReturn\') && executed){\n    kynReturnToHaz(u);\n  }\n  unitActed(u);\n}\nasync function kyn_DeathCall(u, target){\n  if(!target || target.side===u.side){ appendLog(\'死亡宣告 目标无效\'); return; }\n  await telegraphThenImpact([{r:target.r,c:target.c}]);\n  const thresh = Math.ceil(target.maxHp*0.30);\n  let executed = false;\n\n  if(target.hp<=thresh){\n    damageUnit(target.id, target.hp, 0, `${u.name} 死亡宣告 处决 ${target.name}`, u.id,{skillFx:\'kyn:死亡宣告\'});\n    executed = true;\n  } else {\n    const before = target.hp;\n    damageUnit(target.id, 50, 30, `${u.name} 死亡宣告 重创 ${target.name}`, u.id,{skillFx:\'kyn:死亡宣告\'});\n    if(before>0 && target.hp<=0) executed = true;\n  }\n  if(u.passives.includes(\'kynReturn\') && executed){\n    kynReturnToHaz(u);\n  }\n  unitActed(u);\n}\n// Kyn：割喉飞刃（4格内单体 20HP + 流血1 + 恐惧1）\nasync function kyn_ThroatBlade(u, aim){\n  const tu = getUnitAt(aim.r, aim.c);\n  if(!tu || tu.side===\'enemy\'){ appendLog(\'割喉飞刃 未命中\'); unitActed(u); return; }\n  if(mdist(u,tu) > 4){ appendLog(\'割喉飞刃 超出射程（≤4）\'); unitActed(u); return; }\n  await telegraphThenImpact([{r:tu.r,c:tu.c}]);\n  const dmg = calcOutgoingDamage(u,20,tu,\'割喉飞刃\');\n  cameraFocusOnCell(tu.r, tu.c);\n  damageUnit(tu.id, dmg, 0, `${u.name} 割喉飞刃 命中 ${tu.name}`, u.id,{skillFx:\'kyn:割喉飞刃\'});\n  addStatusStacks(tu,\'bleed\',1,{label:\'流血\', type:\'debuff\'});\n  addStatusStacks(tu,\'paralyzed\',1,{label:\'恐惧\', type:\'debuff\'});\n  appendLog(`${tu.name} 附加 流血+1、恐惧+1`);\n  unitActed(u);\n}\n// Kyn：影杀之舞（2步 常态 3x3 AOE 30，随后免费移动1格；不受掩体）\nasync function kyn_ShadowDance_AOE(u){\n  const cells = range_square_n(u,1);\n  await telegraphThenImpact(cells);\n  const seen=new Set(); let hits=0;\n  for(const c of cells){\n    const tu=getUnitAt(c.r,c.c);\n    if(tu && tu.side!==\'enemy\' && !seen.has(tu.id)){\n      damageUnit(tu.id, 30, 0, `${u.name} 影杀之舞 横扫 ${tu.name}`, u.id, {ignoreCover:true, skillFx:\'kyn:影杀之舞\'});\n      seen.add(tu.id); hits++;\n    }\n  }\n  appendLog(`影杀之舞 AOE 命中 ${hits} 人`);\n  // 立即免费移动1格（若有空位）\n  const neigh = range_adjacent(u).filter(p=>!getUnitAt(p.r,p.c));\n  if(neigh.length){\n    const p = neigh[0];\n    showTrail(u.r,u.c,p.r,p.c);\n    u.r=p.r; u.c=p.c; pulseCell(u.r,u.c);\n    appendLog(`${u.name} 影杀之舞：免费位移 1 格`);\n  }\n  unitActed(u);\n}\n\n// —— Neyla 压迫后“终末之影”保证（每回合最多一张；无则添加/替换） ——\nfunction makeNeylaEndShadowSkill(u){\n  return skill(\'终末之影\',2,\'red\',\'全图任意单体 50HP+20SP\',\n    (uu)=> inRadiusCells(uu,999,{allowOccupied:true}).map(p=>({...p,dir:uu.facing})),\n    (uu,aim)=> neyla_EndShadow(uu,aim),\n    {aoe:false},\n    {cellTargeting:true, castMs:1200}\n  );\n}\nfunction ensureNeylaEndShadowGuarantee(u){\n  if(!u || u.id!==\'neyla\' || !u.oppression) return;\n  const pool = u.skillPool || [];\n  const firstIdx = pool.findIndex(s=>s && s.name===\'终末之影\');\n  for(let i=pool.length-1;i>=0;i--){\n    if(i!==firstIdx && pool[i] && pool[i].name===\'终末之影\'){\n      pool.splice(i,1);\n    }\n  }\n  if(firstIdx>=0) return;\n  const endShadow = makeNeylaEndShadowSkill(u);\n  if(pool.length < SKILLPOOL_MAX){\n    pool.push(endShadow);\n  } else {\n    const idx = Math.floor(Math.random()*pool.length);\n    pool[idx] = endShadow;\n  }\n  appendLog(\'Neyla 压迫：已保证“终末之影”在手牌中（最多仅一张）\');\n}\n\n// —— 技能池/抽牌（含调整：Katz/Nelya/Kyn 技能）；移动卡统一蓝色 —— \nfunction skill(name,cost,color,desc,rangeFn,execFn,estimate={},meta={}){ return {name,cost,color,desc,rangeFn,execFn,estimate,meta}; }\nfunction buildSkillFactoriesForUnit(u){\n  const F=[];\n  if(u.id===\'adora\'){\n    F.push(\n      { key:\'短匕轻挥\', prob:0.85, cond:()=>true, make:()=> skill(\'短匕轻挥\',1,\'green\',\'邻格 10HP +5SP（背刺x1.5）\',\n        (uu,aimDir,aimCell)=> aimCell && mdist(uu,aimCell)===1? [{r:aimCell.r,c:aimCell.c,dir:cardinalDirFromDelta(aimCell.r-uu.r,aimCell.c-uu.c)}] : range_adjacent(uu),\n        (uu,target)=> adoraDagger(uu,target),\n        {},\n        {castMs:900}\n      )},\n      { key:\'枪击\', prob:0.65, cond:()=>inventory.pistol, make:()=> skill(\'枪击\',1,\'green\',\'指定方向整排 10HP+5SP（需手枪）\',\n        (uu,aimDir)=> aimDir? range_line(uu,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_line(uu,d).forEach(x=>a.push(x)); return a;})(),\n        (uu,desc)=> playerGunExec(uu,desc),\n        {aoe:true},\n        {castMs:900}\n      )},\n      { key:\'呀！你不要靠近我呀！！\', prob:0.40, cond:()=>true, make:()=> skill(\'呀！你不要靠近我呀！！\',2,\'blue\',\'位移≤5；若相邻敌人≤50%HP，追击一次短匕\',\n        (uu)=> range_move_radius(uu,5),\n        (uu,payload)=> adoraPanicMove(uu,payload),\n        {},\n        {moveSkill:true, moveRadius:5, castMs:600}\n      )},\n      { key:\'自制粉色迷你电击装置\', prob:0.30, cond:()=>true, make:()=> skill(\'自制粉色迷你电击装置\',3,\'red\',\'前方1-2格 10HP 15SP；叠1层眩晕；并使目标下回合-1步\',\n        (uu,aimDir)=> aimDir? range_forward_n(uu,2,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,2,d).forEach(x=>a.push(x)); return a;})(),\n        (uu,target)=> adoraZap(uu,target),\n        {},\n        {castMs:1000}\n      )}\n    );\n    F.push(\n      { key:\'略懂的医术！\', prob:0.25, cond:()=>u.level>=25, make:()=> skill(\'略懂的医术！\',2,\'pink\',\'以自身为中心5x5内选择友方：+20HP/+15SP，并赋予一层“恢复”Buff\',\n        (uu)=> range_square_n(uu,2).filter(p=>{ const tu=getUnitAt(p.r,p.c); return tu && tu.side===uu.side; }),\n        (uu,aim)=> adoraFieldMedic(uu,aim),\n        {aoe:false},\n        {cellTargeting:true, castMs:900}\n      )},\n      { key:\'加油哇！\', prob:0.20, cond:()=>u.level>=25, make:()=> skill(\'加油哇！\',4,\'orange\',\'以自身为中心5x5内选择友方：赋予 1 层“鸡血”（下一次攻击伤害翻倍，使用后移除）\',\n        (uu)=> range_square_n(uu,2).filter(p=>{ const tu=getUnitAt(p.r,p.c); return tu && tu.side===uu.side; }),\n        (uu,aim)=> adoraCheer(uu,aim),\n        {aoe:false},\n        {cellTargeting:true, castMs:900}\n      )},\n      { key:\'只能靠你了。。\', prob:0.15, cond:()=>u.level>=35, make:()=> skill(\'只能靠你了。。\',4,\'orange\',\'牺牲25HP；以自身为中心5格范围友方，赋予1层“依赖”（下一次攻击造成真实伤害并清空自身SP）\',\n        (uu)=> range_square_n(uu,5).filter(p=>{ const tu=getUnitAt(p.r,p.c); return tu && tu.side===uu.side; }),\n        (uu,aim)=> adoraDepend(uu,aim),\n        {aoe:false},\n        {cellTargeting:true, castMs:900}\n      )}\n    );\n  } else if(u.id===\'dario\'){\n    F.push(\n      { key:\'机械爪击\', prob:0.90, cond:()=>true, make:()=> skill(\'机械爪击\',1,\'green\',\'前方1-2格 15HP\',\n        (uu,aimDir)=> aimDir? range_forward_n(uu,2,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,2,d).forEach(x=>a.push(x)); return a;})(),\n        (uu,targetOrDesc)=> {\n          if(targetOrDesc && targetOrDesc.id) darioClaw(uu,targetOrDesc);\n          else if(targetOrDesc && targetOrDesc.dir){\n            const line = range_forward_n(uu,2,targetOrDesc.dir);\n            let tgt=null; for(const c of line){ const tu=getUnitAt(c.r,c.c); if(tu && tu.side!==\'player\'){ tgt=tu; break; } }\n            if(tgt) darioClaw(uu,tgt); else appendLog(\'机械爪击 未命中\');\n          }\n        },\n        {},\n        {castMs:900}\n      )},\n      { key:\'枪击\', prob:0.65, cond:()=>inventory.pistol, make:()=> skill(\'枪击\',1,\'green\',\'指定方向整排 10HP+5SP（需手枪）\',\n        (uu,aimDir)=> aimDir? range_line(uu,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_line(uu,d).forEach(x=>a.push(x)); return a;})(),\n        (uu,desc)=> playerGunExec(uu,desc),\n        {aoe:true},\n        {castMs:900}\n      )},\n      { key:\'迅捷步伐\', prob:0.40, cond:()=>true, make:()=> skill(\'迅捷步伐\',2,\'blue\',\'位移≤4；最近敌人 SP -5\',\n        (uu)=> range_move_radius(uu,4),\n        (uu,payload)=> darioSwiftMove(uu,payload),\n        {},\n        {moveSkill:true, moveRadius:4, castMs:600}\n      )},\n      { key:\'拿来吧你！\', prob:0.30, cond:()=>true, make:()=> skill(\'拿来吧你！\',3,\'red\',\'方向整排：拉至最近空格 +20HP、叠层、-15SP（小Boss/Boss免疫拉扯）\',\n        (uu,aimDir)=> aimDir? range_line(uu,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_line(uu,d).forEach(x=>a.push(x)); return a;})(),\n        (uu,desc)=> darioPull(uu,desc),\n        {aoe:true},\n        {castMs:1100}\n      )}\n    );\n    F.push(\n      { key:\'先苦后甜\', prob:0.15, cond:()=>u.level>=25 && ((u.skillPool||[]).filter(s=>s && s.name===\'先苦后甜\').length < 2), make:()=> skill(\'先苦后甜\',4,\'orange\',\'自我激励：下个玩家回合额外 +4 步（技能池最多保留2张）\',\n        (uu)=>[{r:uu.r,c:uu.c,dir:uu.facing}],\n        (uu)=> darioSweetAfterBitter(uu),\n        {},\n        {castMs:700}\n      )}\n    );\n  } else if(u.id===\'karma\'){\n    F.push(\n      { key:\'沙包大的拳头\', prob:0.90, cond:()=>true, make:()=> skill(\'沙包大的拳头\',1,\'green\',\'邻格 15HP（连击递增）\',\n        (uu,aimDir,aimCell)=> aimCell && mdist(uu,aimCell)===1? [{r:aimCell.r,c:aimCell.c,dir:cardinalDirFromDelta(aimCell.r-uu.r,aimCell.c-uu.c)}] : range_adjacent(uu),\n        (uu,target)=> karmaPunch(uu,target),\n        {},\n        {castMs:900}\n      )},\n      { key:\'枪击\', prob:0.65, cond:()=>inventory.pistol, make:()=> skill(\'枪击\',1,\'green\',\'指定方向整排 10HP+5SP（需手枪）\',\n        (uu,aimDir)=> aimDir? range_line(uu,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_line(uu,d).forEach(x=>a.push(x)); return a;})(),\n        (uu,desc)=> playerGunExec(uu,desc),\n        {aoe:true},\n        {castMs:900}\n      )},\n      { key:\'都听你的\', prob:0.40, cond:()=>true, make:()=> skill(\'都听你的\',2,\'blue\',\'位移≤3，并恢复自身 5SP（打断连击）\',\n        (uu)=> range_move_radius(uu,3),\n        (uu,payload)=> karmaObeyMove(uu,payload),\n        {},\n        {moveSkill:true, moveRadius:3, castMs:600}\n      )},\n      { key:\'嗜血之握\', prob:0.30, cond:()=>true, make:()=> {\n          const sk = skill(\'嗜血之握\',3,\'red\',\'（需连击≥4）精英100/小Boss80/Boss75/普通处决\',\n            (uu,aimDir)=> aimDir? range_forward_n(uu,2,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,2,d).forEach(x=>a.push(x)); return a;})(),\n            (uu,target)=> karmaGrip(uu,target),\n            {},\n            {requireConsec:4, castMs:900}\n          );\n          return sk;\n        }\n      }\n    );\n    F.push(\n      { key:\'深呼吸\', prob:0.20, cond:()=>u.level>=25 && !(u.skillPool||[]).some(s=>s.name===\'深呼吸\'), make:()=> skill(\'深呼吸\',2,\'white\',\'被动：只要此卡在技能池，伤害+10%；主动使用：自身SP回满并+10HP（使用后该卡被移除）\',\n        (uu)=>[{r:uu.r,c:uu.c,dir:uu.facing}],\n        (uu)=> karmaDeepBreath(uu),\n        {},\n        {castMs:700}\n      )}\n    );\n  } else if(u.id===\'haz\'){\n    if(!u._comeback){\n      F.push(\n        { key:\'鱼叉穿刺\', prob:0.70, cond:()=>true, make:()=> skill(\'鱼叉穿刺\',1,\'green\',\'前方1格 20伤害 自身+10SP\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,1,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,1,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,descOrTarget)=> {\n            let tgt=null, dir=uu.facing;\n            if(descOrTarget && descOrTarget.id) tgt=descOrTarget;\n            else if(descOrTarget && descOrTarget.dir){ dir=descOrTarget.dir; const cell=forwardCellAt(uu,dir,1); if(cell) tgt=getUnitAt(cell.r,cell.c); }\n            if(tgt) haz_HarpoonStab(uu,tgt); else appendLog(\'鱼叉穿刺 未命中\');\n          },\n          {},\n          {castMs:1100}\n        )},\n        { key:\'深海猎杀\', prob:0.60, cond:()=>true, make:()=> skill(\'深海猎杀\',2,\'red\',\'前方3格内命中 25伤害 拉到面前 SP-10\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,3,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,3,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> haz_DeepHunt(uu,desc),\n          {},\n          {castMs:1200}\n        )},\n        { key:\'猎神之叉\', prob:0.65, cond:()=>true, make:()=> skill(\'猎神之叉\',2,\'red\',\'5x5内选择敌人：瞬移至其身旁并造成20(50%概率x2)+15SP并施加流血(2)\',\n          (uu)=> range_square_n(uu,2),\n          (uu,aim)=> { const tu = aim && aim.id ? aim : getUnitAt(aim.r, aim.c); if(tu && tu.side!==\'enemy\') haz_GodFork(uu,tu); else appendLog(\'猎神之叉 未命中\'); },\n          {},\n          {cellTargeting:true, castMs:1200}\n        )},\n        { key:\'锁链缠绕\', prob:0.50, cond:()=>true, make:()=> skill(\'锁链缠绕\',2,\'green\',\'2回合内伤害-40%，下次被打反击10SP，队伍+5SP\',\n          (uu)=>[{r:uu.r,c:uu.c,dir:uu.facing}],\n          (uu)=> haz_ChainShield(uu),\n          {},\n          {castMs:600}\n        )},\n        { key:\'鲸落\', prob:0.30, cond:()=>true, make:()=> skill(\'鲸落\',4,\'red\',\'自身中心5x5 50HP +20SP，并使目标下回合-1步（AOE不受掩体）\',\n          (uu)=> range_square_n(uu,2),\n          (uu)=> haz_WhaleFall(uu),\n          {aoe:true},\n          {castMs:1300}\n        )}\n      );\n    } else {\n      F.push(\n        { key:\'深海猎杀\', prob:0.70, cond:()=>true, make:()=> skill(\'深海猎杀\',2,\'red\',\'前方3格内命中 25伤害 拉到面前 SP-10（力挽狂澜）\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,3,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,3,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> haz_DeepHunt(uu,desc),\n          {},\n          {castMs:1200}\n        )},\n        { key:\'怨念滋生\', prob:0.33, cond:()=>true, make:()=> skill(\'怨念滋生\',1,\'green\',\'全图：对被猎杀标记目标 施加1流血+1恐惧\',\n          (uu)=>[{r:uu.r,c:uu.c,dir:uu.facing}],\n        (uu)=> { if(!hazMarkedTargetId){ appendLog(\'怨念滋生：没有被标记的目标\'); unitActed(uu); return; } const t=units[hazMarkedTargetId]; if(!t||t.hp<=0){ appendLog(\'怨念滋生：标记目标不存在或已倒下\'); unitActed(uu); return; } addTempClassToCells([{r:t.r,c:t.c}],\'highlight-tele\',TELEGRAPH_MS); setTimeout(()=>{ addStatusStacks(t,\'bleed\',1,{label:\'流血\', type:\'debuff\'}); addStatusStacks(t,\'paralyzed\',1,{label:\'恐惧\', type:\'debuff\'}); showSkillFx(\'haz:怨念滋生\',{target:t}); appendLog(`${uu.name} 怨念滋生：对 ${t.name} 施加 1层流血 与 1层恐惧`); }, TELEGRAPH_MS); unitActed(uu); },\n          {},\n          {castMs:800}\n        )},\n        { key:\'付出代价\', prob:0.33, cond:()=>true, make:()=> skill(\'付出代价\',2,\'red\',\'前刺3/穿刺4/横斩(横3x前2)，逐段即时结算\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,4,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,4,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> haz_PayThePrice(uu,desc),\n          {aoe:true},\n          {castMs:2000}\n        )},\n        { key:\'仇恨之叉\', prob:0.33, cond:()=>true, make:()=> skill(\'仇恨之叉\',2,\'red\',\'横斩(横3x前2)+自身5x5重砸，逐段即时结算\',\n          (uu,aimDir)=> aimDir? forwardRectCentered(uu,aimDir,3,2) : (()=>{const a=[]; for(const d in DIRS) forwardRectCentered(uu,d,3,2).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> haz_ForkOfHatred(uu,desc),\n          {aoe:true},\n          {castMs:1900}\n        )}\n      );\n    }\n  } else if(u.id===\'katz\'){\n    if(!u.oppression){\n      F.push(\n        { key:\'矛刺\', prob:0.60, cond:()=>true, make:()=> skill(\'矛刺\',1,\'green\',\'前方1格 20伤 自身+5SP\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,1,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,1,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=>{ let tgt=null, dir=uu.facing; if(desc && desc.dir){ dir=desc.dir; const c=forwardCellAt(uu,dir,1); if(c) tgt=getUnitAt(c.r,c.c); } if(tgt) katz_Thrust(uu,tgt); else appendLog(\'矛刺 未命中\'); },\n          {},\n          {castMs:1000}\n        )},\n        { key:\'链式鞭击\', prob:0.50, cond:()=>true, make:()=> skill(\'链式鞭击\',2,\'red\',\'前方3格逐格 25伤 使下回合-1步\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,3,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,3,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> katz_ChainWhip(uu,desc),\n          {},\n          {castMs:1200}\n        )},\n        { key:\'反复鞭尸\', prob:0.50, cond:()=>true, make:()=> skill(\'反复鞭尸\',3,\'red\',\'前方3格AOE：每轮10/15HP并+5SP，按SP百分比重复（最多5次）\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,3,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,3,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> katz_RepeatedWhip(uu,desc),\n          {},\n          {castMs:1400}\n        )},\n        { key:\'终焉礼炮\', prob:0.35, cond:()=>true, make:()=> skill(\'终焉礼炮\',3,\'red\',\'直线5格 35HP（不受掩体）\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,5,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,5,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> katz_EndSalvo(uu,desc),\n          {aoe:true},\n          {castMs:1400}\n        )}\n      );\n    } else {\n      F.push(\n        { key:\'必须抹杀一切。。\', prob:0.55, cond:()=>true, make:()=> skill(\'必须抹杀一切。。\',2,\'red\',\'前方3格多段：20/30伤（自损5HP/段），每段+5SP（最多5段）\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,3,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,3,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> katz_MustErase(uu,desc),\n          {aoe:true},\n          {castMs:1800}\n        )},\n        { key:\'终焉礼炮\', prob:0.45, cond:()=>true, make:()=> skill(\'终焉礼炮\',3,\'red\',\'直线5格 35HP（不受掩体）\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,5,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,5,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> katz_EndSalvo(uu,desc),\n          {aoe:true},\n          {castMs:1400}\n        )}\n      );\n    }\n  } else if(u.id===\'tusk\'){\n    if(!u.oppression){\n      F.push(\n        { key:\'骨盾猛击\', prob:0.70, cond:()=>true, make:()=> skill(\'骨盾猛击\',1,\'green\',\'邻格 10伤 击退1格\',\n          (uu,aimDir,aimCell)=> aimCell && mdist(uu,aimCell)===1? [{r:aimCell.r,c:aimCell.c,dir:cardinalDirFromDelta(aimCell.r-uu.r,aimCell.c-uu.c)}] : range_adjacent(uu),\n          (uu,target)=> tusk_ShieldBash(uu,target),\n          {},\n          {castMs:1000}\n        )},\n        { key:\'来自深海的咆哮\', prob:0.50, cond:()=>true, make:()=> skill(\'来自深海的咆哮\',2,\'red\',\'3x3范围 敌方SP -20\',\n          (uu)=> range_square_n(uu,1),\n          (uu)=> tusk_DeepRoar(uu),\n          {aoe:true},\n          {castMs:1200}\n        )},\n        { key:\'战争堡垒\', prob:0.45, cond:()=>true, make:()=> skill(\'战争堡垒\',2,\'red\',\'进入防御姿态：3回合内伤害-50%且每回合+10SP（期间无法移动）\',\n          (uu)=>[{r:uu.r,c:uu.c,dir:uu.facing}],\n          (uu)=> tusk_WarFortress(uu),\n          {},\n          {castMs:700}\n        )},\n        { key:\'牛鲨冲撞\', prob:0.45, cond:()=>true, make:()=> skill(\'牛鲨冲撞\',2,\'blue\',\'向一方向冲锋≤3格，撞击第一个敌人造成20伤并击退1格；否则移动到终点\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,3,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,3,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> tusk_BullCharge(uu,desc),\n          {},\n          {moveSkill:true, moveRadius:3, castMs:900}\n        )}\n      );\n    } else {\n      F.push(\n        { key:\'拼尽全力保卫队长\', prob:0.60, cond:()=>true, make:()=> skill(\'拼尽全力保卫队长\',2,\'red\',\'进入反伤姿态：3回合内伤害-40%、每回合+10SP、反弹30%所受HP伤（期间无法移动）\',\n          (uu)=>[{r:uu.r,c:uu.c,dir:uu.facing}],\n          (uu)=> tusk_RetaliateGuard(uu),\n          {},\n          {castMs:700}\n        )}\n      );\n    }\n  } else if(u.id===\'neyla\'){\n    if(!u.oppression){\n      F.push(\n        { key:\'迅捷射击\', prob:0.70, cond:()=>true, make:()=> skill(\'迅捷射击\',1,\'green\',\'4格内单体 15HP +5SP\',\n          (uu,aimDir,aimCell)=> inRadiusCells(uu,4,{allowOccupied:true}).map(p=>({...p,dir:cardinalDirFromDelta(p.r-uu.r,p.c-uu.c)})),\n          (uu,aim)=> neyla_SwiftShot(uu,aim),\n          {aoe:false},\n          {cellTargeting:true, castMs:1100}\n        )},\n        { key:\'穿刺狙击\', prob:0.60, cond:()=>true, make:()=> skill(\'穿刺狙击\',2,\'red\',\'直线6格 穿透 30HP +流血\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,6,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,6,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> neyla_PierceSnipe(uu,desc),\n          {aoe:true},\n          {castMs:1200}\n        )},\n        { key:\'双钩牵制\', prob:0.45, cond:()=>true, make:()=> skill(\'双钩牵制\',2,\'red\',\'前方3格优先最近：拉近1格并赋予恐惧（-1步）\',\n          (uu,aimDir)=> aimDir? range_forward_n(uu,3,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_forward_n(uu,3,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> neyla_DoubleHook(uu,desc),\n          {},\n          {castMs:1100}\n        )},\n        { key:\'终末之影\', prob:0.30, cond:()=>true, make:()=> makeNeylaEndShadowSkill(u) }\n      );\n    } else {\n      F.push(\n        { key:\'终末之影\', prob:0.50, cond:()=>true, make:()=> makeNeylaEndShadowSkill(u) },\n        { key:\'执行……\', prob:0.55, cond:()=>true, make:()=> skill(\'执行……\',2,\'red\',\'前方整排 20伤/20伤（第二枪<15%处决）；自身第一枪-15HP，第二枪-15HP-40SP\',\n          (uu,aimDir)=> aimDir? range_line(uu,aimDir) : (()=>{const a=[]; for(const d in DIRS) range_line(uu,d).forEach(x=>a.push(x)); return a;})(),\n          (uu,desc)=> neyla_ExecuteHarpoons(uu,desc),\n          {aoe:true},\n          {castMs:1800}\n        )}\n      );\n    }\n  } else if(u.id===\'kyn\'){\n    if(!u.oppression){\n      F.push(\n        { key:\'迅影突刺\', prob:0.60, cond:()=>true, make:()=> skill(\'迅影突刺\',1,\'green\',\'5x5内任一敌人身边 20HP（≤25%处决，处决后返身）\',\n          (uu)=> range_square_n(uu,2),\n          (uu,aim)=>{ const tu=getUnitAt(aim.r,aim.c); if(tu && tu.side!==\'enemy\') kyn_ShadowDash(uu,tu); },\n          {aoe:false},\n          {cellTargeting:true, castMs:1200}\n        )},\n        { key:\'死亡宣告\', prob:0.25, cond:()=>true, make:()=> skill(\'死亡宣告\',3,\'red\',\'单体 50HP+30SP（≤30%处决，处决后返身）\',\n          (uu)=> inRadiusCells(uu,6,{allowOccupied:true}).map(p=>({...p,dir:uu.facing})),\n          (uu,aim)=>{ const tu=getUnitAt(aim.r,aim.c); if(tu && tu.side!==\'enemy\') kyn_DeathCall(uu,tu); },\n          {aoe:false},\n          {cellTargeting:true, castMs:1200}\n        )},\n        { key:\'割喉飞刃\', prob:0.40, cond:()=>true, make:()=> skill(\'割喉飞刃\',2,\'red\',\'4格内单体 20HP +流血1 +恐惧1\',\n          (uu,aimDir,aimCell)=> inRadiusCells(uu,4,{allowOccupied:true}).map(p=>({...p,dir:uu.facing})),\n          (uu,aim)=> kyn_ThroatBlade(uu,aim),\n          {aoe:false},\n          {cellTargeting:true, castMs:900}\n        )},\n        { key:\'影杀之舞\', prob:0.50, cond:()=>true, make:()=> skill(\'影杀之舞\',2,\'red\',\'3x3 AOE 30HP（不受掩体）并立刻免费位移1格（常态）\',\n          (uu)=>[{r:uu.r,c:uu.c,dir:uu.facing}],\n          (uu)=> kyn_ShadowDance_AOE(uu),\n          {aoe:true},\n          {castMs:1200}\n        )}\n      );\n    } else {\n      F.push(\n        { key:\'自我了断。。\', prob:0.40, cond:()=>true, make:()=> skill(\'自我了断。。\',2,\'red\',\'5x5内任意敌人：瞬杀，自己HP清零（压迫）\',\n          (uu)=> range_square_n(uu,2),\n          (uu,aim)=>{ const tu=getUnitAt(aim.r,aim.c); if(tu && tu.side!==\'enemy\'){ damageUnit(tu.id, tu.hp, 0, `${uu.name} 自我了断 秒杀 ${tu.name}`, uu.id,{skillFx:\'kyn:自我了断。。\'}); damageUnit(uu.id, uu.hp, 0, `${uu.name} 生命燃尽`, uu.id, {ignoreToughBody:true, skillFx:\'kyn:自我了断。。\', skillFxCtx:{target:uu}}); } unitActed(uu); },\n          {aoe:false},\n          {cellTargeting:true, castMs:1100}\n        )}\n      );\n    }\n  }\n  return F;\n}\nfunction drawOneSkill(u){\n  const fset = buildSkillFactoriesForUnit(u);\n  const viable = fset.filter(f=>f.cond());\n  if(viable.length===0) return null;\n  for(let i=0;i<30;i++){ const f=viable[Math.floor(Math.random()*viable.length)]; if(Math.random()<f.prob) return f.make(); }\n  viable.sort((a,b)=> b.prob-a.prob);\n  return viable[0].make();\n}\nfunction drawSkills(u, n){\n  let toDraw = Math.max(0, Math.min(n, SKILLPOOL_MAX - u.skillPool.length));\n  while(toDraw>0){ const sk=drawOneSkill(u); if(!sk) break; u.skillPool.push(sk); toDraw--; }\n  if(u.skillPool.length > SKILLPOOL_MAX) u.skillPool.length = SKILLPOOL_MAX;\n}\nfunction ensureStartHand(u){ if(u.dealtStart) return; u.skillPool.length = 0; drawSkills(u, START_HAND_COUNT); u.dealtStart = true; appendLog(`${u.name} 起手手牌：${u.skillPool.map(s=>s.name).join(\' / \')}`); }\n\n// —— GOD’S WILL —— \nfunction disarmGodsWill(){\n  godsWillArmed = false;\n  if(godsWillBtn) godsWillBtn.classList.remove(\'armed\');\n  if(godsWillMenuEl){ godsWillMenuEl.remove(); godsWillMenuEl = null; }\n  appendLog(\'GOD’S WILL：退出选取模式\');\n}\nfunction showGodsWillMenuAtUnit(u){\n  if(!battleAreaEl || !u || u.hp<=0){ appendLog(\'GOD’S WILL：目标无效或已倒下\'); disarmGodsWill(); return; }\n  if(godsWillMenuEl){ godsWillMenuEl.remove(); godsWillMenuEl=null; }\n  const p = getCellCenter(u.r, u.c);\n  const areaRect = battleAreaEl.getBoundingClientRect();\n  godsWillMenuEl = document.createElement(\'div\');\n  godsWillMenuEl.className = \'gods-menu\';\n  godsWillMenuEl.style.left = `${Math.max(8, p.x + areaRect.left + 8)}px`;\n  godsWillMenuEl.style.top  = `${Math.max(8, p.y + areaRect.top  - 8)}px`;\n  godsWillMenuEl.innerHTML = `\n    <div class="title">GOD’S WILL → ${u.name}<\/div>\n    <div class="row">\n      <button class="kill">杀死<\/button>\n      <button class="onehp">留 1 HP<\/button>\n      <button class="cancel">取消<\/button>\n    <\/div>\n  `;\n  godsWillMenuEl.querySelector(\'.kill\').onclick = (e)=>{\n    e.stopPropagation();\n    const before = u.hp;\n    u.hp = 0;\n    appendLog(`GOD’S WILL：${u.name} 被直接抹除（-${before} HP）`);\n    cameraShake(\'heavy\');\n    showAttackFx({target: u, trueDamage: true, heavy: true});\n    showDamageFloat(u,before,0);\n    if(before>0){ showDeathFx(u); }\n    checkHazComebackStatus();\n    renderAll();\n    disarmGodsWill();\n  };\n  godsWillMenuEl.querySelector(\'.onehp\').onclick = (e)=>{\n    e.stopPropagation();\n    if(u.hp>1){\n      const delta = u.hp - 1;\n      u.hp = 1;\n      appendLog(`GOD’S WILL：${u.name} 被压到 1 HP（-${delta} HP）`);\n      const heavy = delta >= Math.max(18, Math.round(u.maxHp * 0.3));\n      cameraShake(heavy ? \'heavy\' : \'normal\');\n      showAttackFx({target: u, heavy, trueDamage: true});\n      showDamageFloat(u,delta,0);\n    } else {\n      appendLog(`GOD’S WILL：${u.name} 已是 1 HP`);\n    }\n    checkHazComebackStatus();\n    renderAll();\n    disarmGodsWill();\n  };\n  godsWillMenuEl.querySelector(\'.cancel\').onclick = (e)=>{ e.stopPropagation(); disarmGodsWill(); };\n  document.body.appendChild(godsWillMenuEl);\n}\nfunction toggleGodsWill(){\n  godsWillArmed = !godsWillArmed;\n  if(godsWillBtn){\n    if(godsWillArmed){\n      godsWillBtn.classList.add(\'armed\');\n      appendLog(\'GOD’S WILL：已开启，点击任意单位选择“杀死/留 1 HP”，ESC 可取消\');\n    } else {\n      godsWillBtn.classList.remove(\'armed\');\n      appendLog(\'GOD’S WILL：关闭\');\n    }\n  }\n  if(!godsWillArmed && godsWillMenuEl){ godsWillMenuEl.remove(); godsWillMenuEl=null; }\n}\n// 全屏切换（原生优先，失败时启用模拟全屏）\nfunction setSimFullscreen(on){\n  isSimFullscreen = !!on;\n  document.documentElement.classList.toggle(\'fs-sim\', on);\n  document.body.classList.toggle(\'fs-sim\', on);\n  if(fsBtn){\n    fsBtn.classList.toggle(\'on\', on || !!document.fullscreenElement);\n    fsBtn.textContent = (on || document.fullscreenElement) ? \'Exit Full Screen\' : \'Full Screen\';\n  }\n  // 刷新覆盖\n  setTimeout(()=> refreshLargeOverlays(), 80);\n}\nfunction toggleFullscreen(){\n  if(document.fullscreenElement){\n    document.exitFullscreen().finally(()=> setSimFullscreen(false));\n    return;\n  }\n  if(document.documentElement.requestFullscreen){\n    document.documentElement.requestFullscreen().then(()=>{\n      setSimFullscreen(false);\n    }).catch(()=>{\n      setSimFullscreen(!isSimFullscreen);\n    });\n  } else {\n    setSimFullscreen(!isSimFullscreen);\n  }\n}\ndocument.addEventListener(\'fullscreenchange\', ()=>{\n  if(fsBtn){\n    fsBtn.classList.toggle(\'on\', !!document.fullscreenElement);\n    fsBtn.textContent = document.fullscreenElement ? \'Exit Full Screen\' : \'Full Screen\';\n  }\n  setTimeout(()=> refreshLargeOverlays(), 80);\n});\n\n// —— UI/交互 —— \nfunction buildGrid(){\n  if(!battleAreaEl) return;\n  // 确保 --cell 可用，避免“无角色/看不到格子”\n  battleAreaEl.style.setProperty(\'--cell\', `${CELL_SIZE}px`);\n  battleAreaEl.style.gridTemplateColumns = `repeat(${COLS}, var(--cell))`;\n  battleAreaEl.style.gridTemplateRows = `repeat(${ROWS}, var(--cell))`;\n  const preservedFxLayer = fxLayer;\n  battleAreaEl.innerHTML = \'\';\n  for(let r=1;r<=ROWS;r++){\n    for(let c=1;c<=COLS;c++){\n      const cell = document.createElement(\'div\');\n      cell.className = \'cell\';\n      if(isVoidCell(r,c)) cell.classList.add(\'void\');\n      if(isCoverCell(r,c)) cell.classList.add(\'cover\');\n      cell.dataset.r=r; cell.dataset.c=c;\n      const coord=document.createElement(\'div\'); coord.className=\'coord\'; coord.textContent=`${r},${c}`; cell.appendChild(coord);\n\n      cell.addEventListener(\'click\', ()=>{\n        if(interactionLocked) return;\n        const rr=+cell.dataset.r, cc=+cell.dataset.c;\n        if(_skillSelection){\n          handleSkillConfirmCell(_skillSelection.unit,_skillSelection.skill,{r:rr,c:cc});\n          return;\n        }\n        const occ = getUnitAt(rr,cc);\n        if(occ){\n          if(godsWillArmed){ showGodsWillMenuAtUnit(occ); return; }\n          onUnitClick(occ.id); return;\n        }\n        onCellClick(rr,cc);\n      });\n      cell.addEventListener(\'mouseenter\', ()=>{\n        if(interactionLocked) return;\n        if(_skillSelection){\n          const rr=+cell.dataset.r, cc=+cell.dataset.c;\n          handleSkillPreviewCell(_skillSelection.unit,_skillSelection.skill,{r:rr,c:cc});\n        }\n      });\n      cell.addEventListener(\'contextmenu\', (e)=>{ e.preventDefault(); if(interactionLocked) return; clearSkillAiming(); renderAll(); });\n      battleAreaEl.appendChild(cell);\n    }\n  }\n  if(preservedFxLayer){\n    battleAreaEl.appendChild(preservedFxLayer);\n  }\n}\nfunction refreshLargeOverlays(){\n  if(!battleAreaEl) return;\n  battleAreaEl.querySelectorAll(\'.largeOverlay\').forEach(n=>n.remove());\n  for(const id in units){\n    const u=units[id];\n    if(u && u.hp>0 && u.size===2){\n      renderLargeUnitOverlay(u);\n    }\n  }\n}\nfunction placeUnits(){\n  if(!battleAreaEl) return;\n  document.querySelectorAll(\'.cell .unit\').forEach(n=>n.remove());\n  battleAreaEl.querySelectorAll(\'.largeOverlay\').forEach(n=>n.remove());\n\n  for(const id in units){\n    const u=units[id]; if(u.hp<=0) continue;\n\n    if(u.size===2){\n      renderLargeUnitOverlay(u);\n      continue;\n    }\n\n    const sel=`.cell[data-r="${u.r}"][data-c="${u.c}"]`;    const cell=document.querySelector(sel);\n    if(!cell) continue;\n    const div=document.createElement(\'div\');\n    div.className=\'unit \' + (u.side===\'player\'?\'player\':\'enemy\');\n    if(u.id===\'haz\'){ div.classList.add(\'haz-glow\'); if(u._comeback) div.classList.add(\'comeback\'); }\n    div.dataset.id=id;\n    div.dataset.facing = u.facing || \'right\';\n\n    div.addEventListener(\'click\',(e)=>{\n      if(interactionLocked) return;\n      if(godsWillArmed){\n        e.stopPropagation();\n        showGodsWillMenuAtUnit(u);\n        return;\n      }\n      if(_skillSelection){\n        e.stopPropagation();\n        handleSkillConfirmCell(_skillSelection.unit,_skillSelection.skill,{r:u.r,c:u.c});\n        return;\n      }\n      e.stopPropagation();\n      onUnitClick(id);\n    });\n\n    const hpPct = Math.max(0, Math.min(100, (u.hp/u.maxHp*100)||0));\n    const spPct = Math.max(0, Math.min(100, (u.maxSp ? (u.sp/u.maxSp*100) : 0)));\n    div.innerHTML = `\n      <div>${u.name}<\/div>\n      <div class="hpbar"><div class="hpfill" style="width:${hpPct}%"><\/div><\/div>\n      <div class="spbar"><div class="spfill" style="width:${spPct}%"><\/div><\/div>\n    `;\n    const facingArrow=document.createElement(\'div\');\n    facingArrow.className=\'facing-arrow\';\n    div.appendChild(facingArrow);\n    cell.appendChild(div);\n  }\n}\n\n//part 1 结束\nfunction renderLargeUnitOverlay(u){\n  // Pixel-perfect 2x2 overlay using actual cell offsets to avoid rounding drift\n  const tl = getCellEl(u.r, u.c);\n  const br = getCellEl(u.r+1, u.c+1);\n  if(!tl || !br || !battleAreaEl) return;\n\n  const left   = tl.offsetLeft;\n  const top    = tl.offsetTop;\n  const right  = br.offsetLeft + br.offsetWidth;\n  const bottom = br.offsetTop  + br.offsetHeight;\n  const width  = right - left;\n  const height = bottom - top;\n\n  const overlay = document.createElement(\'div\');\n  overlay.className = \'largeOverlay \' + (u.side===\'player\'?\'player\':\'enemy\');\n  overlay.dataset.facing = u.facing || \'right\';\n  overlay.style.position = \'absolute\';\n  overlay.style.left = left + \'px\';\n  overlay.style.top  = top  + \'px\';\n  overlay.style.width  = width  + \'px\';\n  overlay.style.height = height + \'px\';\n  overlay.style.background = \'rgba(255,77,79,0.08)\';\n  overlay.style.border = \'1px solid rgba(255,77,79,0.35)\';\n  overlay.style.borderRadius = \'10px\';\n  overlay.style.color = \'#e9eefc\';\n  overlay.style.display = \'grid\';\n  overlay.style.gridTemplateRows = \'auto auto auto\';\n  overlay.style.placeItems = \'center\';\n  overlay.style.padding = \'6px 8px\';\n  overlay.style.pointerEvents = \'auto\';\n\n  overlay.addEventListener(\'click\', (e)=>{\n    if(interactionLocked) return;\n    if(_skillSelection){\n      const attacker = _skillSelection.unit;\n      const skill = _skillSelection.skill;\n      const aim = chooseBestAimCellForLargeTarget(attacker, skill, u) || {r:u.r, c:u.c};\n      handleSkillConfirmCell(attacker, skill, aim);\n      return;\n    }\n    onUnitClick(u.id);\n  });\n\n  const hpPct = Math.max(0, Math.min(100, (u.hp/u.maxHp*100)||0));\n  const spPct = Math.max(0, Math.min(100, (u.maxSp ? (u.sp/u.maxSp*100) : 0)));\n\n  overlay.innerHTML = `\n    <div class="title">${u.name}<\/div>\n    <div class="hpbar"><div class="hpfill" style="width:${hpPct}%"><\/div><\/div>\n    <div class="spbar"><div class="spfill" style="width:${spPct}%"><\/div><\/div>\n  `;\n  const facingArrow=document.createElement(\'div\');\n  facingArrow.className=\'facing-arrow\';\n  overlay.appendChild(facingArrow);\n\n  battleAreaEl.appendChild(overlay);\n}\n\n// —— 大体型（2x2）瞄准辅助 —— \nfunction getCoveredCells(u){\n  if(!u || u.hp<=0) return [];\n  if(u.size===2) return [{r:u.r,c:u.c},{r:u.r+1,c:u.c},{r:u.r,c:u.c+1},{r:u.r+1,c:u.c+1}];\n  return [{r:u.r,c:u.c}];\n}\nfunction chooseBestAimCellForLargeTarget(attacker, sk, target){\n  if(!attacker || !sk || !target) return null;\n  const cells = getCoveredCells(target);\n  // 优先：在技能范围内且与攻击者最近的覆盖格\n  let best=null, bestD=1e9;\n  for(const c of cells){\n    const dir = resolveAimDirForSkill(attacker, sk, c);\n    let inRange=false;\n    try{\n      const rc = sk.rangeFn(attacker, dir, c) || [];\n      inRange = rangeIncludeCell(rc, c);\n    }catch(e){ inRange=false; }\n    if(inRange){\n      const d = mdist(attacker, c);\n      if(d < bestD){ bestD=d; best=c; }\n    }\n  }\n  if(best) return best;\n  // 兜底：返回最近覆盖格\n  let nearest=cells[0], nd=mdist(attacker, cells[0]);\n  for(const c of cells){ const d=mdist(attacker,c); if(d<nd){ nd=d; nearest=c; } }\n  return nearest;\n}\n\nfunction summarizeNegatives(u){\n  let parts=[];\n  if(u._staggerStacks && (u.stunThreshold||1)>1) parts.push(`叠层${u._staggerStacks}/${u.stunThreshold}`);\n  if(u.status.stunned>0) parts.push(`眩晕x${u.status.stunned}`);\n  if(u.status.paralyzed>0) parts.push(`恐惧x${u.status.paralyzed}`);\n  if(u.status.bleed>0) parts.push(`流血x${u.status.bleed}`);\n  if(u.status.hazBleedTurns>0) parts.push(`Haz流血x${u.status.hazBleedTurns}`);\n  if(u.status.recoverStacks>0) parts.push(`恢复x${u.status.recoverStacks}`);\n  if(u.status.jixueStacks>0) parts.push(`鸡血x${u.status.jixueStacks}`);\n  if(u.status.dependStacks>0) parts.push(`依赖x${u.status.dependStacks}`);\n  if(u._spBroken) parts.push(`SP崩溃`);\n  if(u._spCrashVuln) parts.push(\'SP崩溃易伤\');\n  if(hazMarkedTargetId && u.id === hazMarkedTargetId) parts.push(\'猎杀标记\');\n  if(u._stanceType && u._stanceTurns>0){\n    parts.push(u._stanceType===\'defense\' ? `防御姿态(${u._stanceTurns})` : `反伤姿态(${u._stanceTurns})`);\n  }\n  return parts.join(\' \');\n}\nfunction renderStatus(){\n  if(!partyStatus) return;\n  partyStatus.innerHTML=\'\';\n  for(const id of [\'adora\',\'dario\',\'karma\']){\n    const u=units[id]; if(!u) continue;\n    const el=document.createElement(\'div\'); el.className=\'partyRow\';\n    el.innerHTML=`<strong>${u.name}<\/strong> HP:${u.hp}/${u.maxHp} SP:${u.sp}/${u.maxSp} ${summarizeNegatives(u)}`;\n    partyStatus.appendChild(el);\n  }\n  const enemyWrap=document.createElement(\'div\'); enemyWrap.style.marginTop=\'10px\'; enemyWrap.innerHTML=\'<strong>敌方（七海作战队）<\/strong>\';\n  const enemyUnits = Object.values(units).filter(u=>u.side===\'enemy\' && u.hp>0);\n  for(const u of enemyUnits){\n    const el=document.createElement(\'div\'); el.className=\'partyRow small\';\n    el.innerHTML=`${u.name} HP:${u.hp}/${u.maxHp} SP:${u.sp}/${u.maxSp} ${u.oppression?\'[压迫] \':\'\'}${u._comeback?\'[力挽狂澜] \':\'\'}${summarizeNegatives(u)}`;\n    enemyWrap.appendChild(el);\n  }\n  partyStatus.appendChild(enemyWrap);\n}\nfunction updateStepsUI(){\n  if(playerStepsEl) playerStepsEl.textContent=playerSteps;\n  if(enemyStepsEl) enemyStepsEl.textContent=enemySteps;\n  if(roundCountEl) roundCountEl.textContent = String(roundsPassed);\n}\n\n// —— 选中/瞄准 —— \nfunction canUnitMove(u){\n  if(!u) return false;\n  if(u._stanceType && u._stanceTurns>0) return false; // 姿态期间禁止移动\n  return true;\n}\nfunction clearSkillAiming(){ _skillSelection=null; clearHighlights(); }\nfunction clearAllSelection(){ _skillSelection=null; selectedUnitId=null; clearHighlights(); if(skillPool) skillPool.innerHTML=\'\'; if(selectedInfo) selectedInfo.innerHTML=\'\'; }\nfunction startSkillAiming(u,sk){\n  if(interactionLocked || !u || u.hp<=0) return;\n  clearHighlights();\n  _skillSelection={unit:u,skill:sk};\n  appendLog(`${u.name} 选择了技能：${sk.name}，移动鼠标到目标格以预览并点击`);\n  handleSkillPreviewCell(u,sk,{r:u.r,c:u.c});\n}\nfunction rangeIncludeCell(cells, aimCell){ return cells.some(c=>c.r===aimCell.r && c.c===aimCell.c); }\nfunction resolveAimDirForSkill(u, sk, aimCell){\n  const vecDir = cardinalDirFromDelta(aimCell.r - u.r, aimCell.c - u.c);\n  try{\n    const cells = sk.rangeFn(u, vecDir, aimCell) || [];\n    if(rangeIncludeCell(cells, aimCell)) return vecDir;\n  }catch(e){}\n  for(const dir of Object.keys(DIRS)){\n    let cells=[];\n    try{ cells = sk.rangeFn(u, dir, aimCell) || []; }catch(e){ cells=[]; }\n    if(rangeIncludeCell(cells, aimCell)) return dir;\n  }\n  return vecDir;\n}\nfunction handleSkillPreviewCell(u, sk, aimCell){\n  if(interactionLocked || !u || u.hp<=0) return;\n  clearHighlights();\n  const aimDir = resolveAimDirForSkill(u, sk, aimCell);\n  const cells = sk.rangeFn(u, aimDir, aimCell) || [];\n  for(const c of cells) markCell(c.r,c.c,\'skill\');\n  const inPreview = rangeIncludeCell(cells, aimCell);\n  if(inPreview) markCell(aimCell.r, aimCell.c, \'target\');\n}\nfunction consumeCardFromHand(u, sk){ if(!u || !u.skillPool) return; const idx=u.skillPool.indexOf(sk); if(idx>=0) u.skillPool.splice(idx,1); }\nfunction discardSkill(u, sk){\n  if(interactionLocked) return;\n  if(!u || !sk) return;\n  if(u.side !== currentSide){ appendLog(\'现在不是你的回合\'); return; }\n  if(u.hp<=0){ appendLog(\'该单位已无法行动\'); return; }\n  if(_skillSelection && _skillSelection.unit===u && _skillSelection.skill===sk){ clearSkillAiming(); }\n  consumeCardFromHand(u, sk);\n  appendLog(`${u.name} 弃置了技能：${sk.name}`);\n  renderAll(); showSelected(u);\n}\nfunction handleSkillConfirmCell(u, sk, aimCell){\n  if(interactionLocked || !u || u.hp<=0) return;\n  if(!_skillSelection) return;\n\n  if(sk.meta && sk.meta.moveSkill && !canUnitMove(u)){\n    appendLog(`${u.name} 处于姿态中，无法进行任何移动`);\n    clearSkillAiming(); renderAll(); return;\n  }\n\n  if(sk.meta && sk.meta.requireConsec && (u.consecAttacks||0) < sk.meta.requireConsec){\n    appendLog(`未满足使用条件：需要当前连击 ≥ ${sk.meta.requireConsec}`);\n    clearSkillAiming(); renderAll(); return;\n  }\n\n  const currentSteps = (u.side===\'player\')? playerSteps : enemySteps;\n  if(sk.cost > currentSteps){ appendLog(\'步数不足\'); clearSkillAiming(); renderAll(); return; }\n\n  const aimDir = resolveAimDirForSkill(u, sk, aimCell);\n  const cells = sk.rangeFn(u, aimDir, aimCell) || [];\n  if(!rangeIncludeCell(cells, aimCell)){ appendLog(\'该格不在技能范围内\'); return; }\n\n  if(u.side===\'player\'){ playerSteps = Math.max(0, playerSteps - sk.cost); } else { enemySteps = Math.max(0, enemySteps - sk.cost); }\n\n  if(aimDir && (aimCell.r !== u.r || aimCell.c !== u.c)){\n    setUnitFacing(u, aimDir);\n  }\n\n  const targetUnit = getUnitAt(aimCell.r, aimCell.c);\n  try{\n    if(sk.meta && sk.meta.moveSkill) sk.execFn(u, {moveTo: aimCell});\n    else if(sk.meta && sk.meta.cellTargeting) sk.execFn(u, aimCell);\n    else if(sk.estimate && sk.estimate.aoe) sk.execFn(u, {dir:aimDir});\n    else if(targetUnit) sk.execFn(u, targetUnit);\n    else sk.execFn(u, {r:aimCell.r,c:aimCell.c,dir:aimDir});\n  }catch(e){ console.error(\'技能执行错误\',e); appendLog(`[错误] 技能执行失败：${sk.name} - ${e.message}`); }\n\n  consumeCardFromHand(u, sk);\n  clearSkillAiming();\n  renderAll();\n  showSelected(u);\n\n  if(u.id===\'karma\' && sk.name!==\'沙包大的拳头\'){\n    if(u.consecAttacks>0) appendLog(`${u.name} 的连击被打断（使用其他技能）`);\n    u.consecAttacks = 0;\n  }\n\n  unitActed(u);\n  setTimeout(()=>{ checkEndOfTurn(); }, 220);\n}\nfunction onUnitClick(id){\n  if(interactionLocked) return;\n  const u=units[id]; if(!u) return;\n  if(godsWillArmed){ showGodsWillMenuAtUnit(u); return; }\n  if(u.side===\'enemy\' && ENEMY_IS_AI_CONTROLLED){ appendLog(\'敌方单位由 AI 控制，无法手动操作\'); selectedUnitId=id; showSelected(u); return; }\n  if(u.side===currentSide && u.status.stunned) appendLog(`${u.name} 眩晕中，无法行动`);\n  selectedUnitId=id; showSelected(u);\n}\nfunction onCellClick(r,c){\n  if(interactionLocked) return;\n  if(_skillSelection) return;\n  if(!selectedUnitId) {\n    if(godsWillArmed){ appendLog(\'GOD’S WILL：请直接点击单位，而非空格\'); }\n    return;\n  }\n  const sel=units[selectedUnitId]; if(!sel || sel.hp<=0) return;\n\n  if(sel.side===\'enemy\' && ENEMY_IS_AI_CONTROLLED){ appendLog(\'敌方单位由 AI 控制\'); return; }\n  if(sel.side!==currentSide){ appendLog(\'不是该单位的回合\'); return; }\n  if(sel.status.stunned){ appendLog(`${sel.name} 眩晕中，无法行动`); return; }\n  if(!canUnitMove(sel)){ appendLog(`${sel.name} 处于${sel._stanceType===\'defense\'?\'防御姿态\':\'反伤姿态\'}，本回合不能移动`); return; }\n\n  const key=`${r},${c}`; if(!highlighted.has(key)) return;\n  if(playerSteps<=0 && sel.side===\'player\'){ appendLog(\'剩余步数不足\'); return; }\n  const occ=getUnitAt(r,c); if(occ){ appendLog(\'格子被占用\'); return; }\n\n  if(sel.size===2){ if(!canPlace2x2(sel, r, c)){ appendLog(\'该位置无法容纳 2x2 单位\'); return; } }\n\n  const moveDir = cardinalDirFromDelta(r - sel.r, c - sel.c);\n  setUnitFacing(sel, moveDir);\n  sel.r=r; sel.c=c;\n  if(sel.side===\'player\') playerSteps=Math.max(0, playerSteps-1); else enemySteps=Math.max(0, enemySteps-1);\n  appendLog(`${sel.name} 移动到 (${r},${c})`);\n  if(sel.side!==\'player\') cameraFocusOnCell(r,c);\n  pulseCell(r,c);\n  if(sel.id===\'karma\' && sel.consecAttacks>0){ appendLog(`${sel.name} 的连击被打断（移动）`); sel.consecAttacks=0; }\n  unitActed(sel);\n  clearHighlights(); renderAll(); showSelected(sel);\n  setTimeout(()=>{ checkEndOfTurn(); }, 160);\n}\nfunction showSelected(u){\n  clearSkillAiming();\n  const base=`<strong>${u.name}<\/strong><br>HP: ${u.hp}/${u.maxHp} SP:${u.sp}/${u.maxSp} 级别:${u.level} ${summarizeNegatives(u)}`;\n  let extra=\'\';\n  if(u.skillPool && u.skillPool.length){ extra += `<div class="partyRow small">手牌(${u.skillPool.length}/${SKILLPOOL_MAX}): ${u.skillPool.map(s=>s.name).join(\' / \')}<\/div>`; }\n  if(selectedInfo) selectedInfo.innerHTML = base + extra;\n\n  if(skillPool){\n    if(u.side===\'enemy\'){ skillPool.innerHTML = `<div class="partyRow small">敌方单位（AI 控制），无法操作<\/div>`; }\n    else if(currentSide!==\'player\'){ skillPool.innerHTML = `<div class="partyRow small">不是你的回合<\/div>`; }\n    else {\n      skillPool.innerHTML = \'\';\n      if(!u.dealtStart) ensureStartHand(u);\n      const pool = u.skillPool || [];\n      for(const sk of pool){\n        const stepsOk = playerSteps>=sk.cost;\n        const colorClass = sk.color || ((sk.meta && sk.meta.moveSkill) ? \'blue\' : (sk.cost>=3 ? \'red\' : \'green\'));\n\n        const card=document.createElement(\'div\');\n        card.className=\'skillCard \'+colorClass;\n        if(!stepsOk) card.classList.add(\'disabled\');\n\n        const header=document.createElement(\'div\');\n        header.style.display=\'flex\';\n        header.style.alignItems=\'center\';\n        header.style.justifyContent=\'space-between\';\n\n        const leftBox=document.createElement(\'div\');\n        leftBox.innerHTML = `<strong>${sk.name}<\/strong><div class="small">${sk.desc||\'\'}<\/div>`;\n\n        const rightBox=document.createElement(\'div\');\n        rightBox.textContent = `${sk.cost} 步`;\n\n        const discardBtn=document.createElement(\'button\');\n        discardBtn.textContent=\'弃置\';\n        discardBtn.className=\'discardBtn\';\n        discardBtn.style.marginLeft=\'8px\';\n        discardBtn.style.fontSize=\'12px\';\n        discardBtn.style.padding=\'2px 6px\';\n        discardBtn.addEventListener(\'click\',(e)=>{ e.stopPropagation(); if(interactionLocked) return; discardSkill(u, sk); });\n\n        const rightWrap=document.createElement(\'div\');\n        rightWrap.style.display=\'flex\';\n        rightWrap.style.alignItems=\'center\';\n        rightWrap.style.gap=\'6px\';\n        rightWrap.appendChild(rightBox);\n        rightWrap.appendChild(discardBtn);\n\n        header.appendChild(leftBox);\n        header.appendChild(rightWrap);\n        card.appendChild(header);\n\n        card.addEventListener(\'contextmenu\',(e)=>{ e.preventDefault(); if(interactionLocked) return; discardSkill(u,sk); });\n        card.addEventListener(\'click\', ()=>{\n          if(interactionLocked) return;\n          if(!stepsOk){ appendLog(\'步数不足\'); return; }\n          if(u.status.stunned){ appendLog(`${u.name} 眩晕中`); return; }\n          if(u.hp<=0){ appendLog(`${u.name} 已阵亡，无法行动`); return; }\n          if(sk.meta && sk.meta.moveSkill && !canUnitMove(u)){ appendLog(`${u.name} 处于姿态中，无法移动`); return; }\n          startSkillAiming(u, sk);\n        });\n\n        skillPool.appendChild(card);\n      }\n    }\n  }\n\n  clearHighlights();\n  if(u.side===currentSide && !u.status.stunned && u.side===\'player\' && canUnitMove(u)){\n    const moves=range_move_radius(u,1).filter(p=>!getUnitAt(p.r,p.c));\n    for(const m of moves){ const key=`${m.r},${m.c}`; highlighted.add(key); markCell(m.r,m.c,\'move\'); }\n  }\n}\nfunction clearHighlights(){ highlighted.clear(); document.querySelectorAll(\'.cell\').forEach(cell=>cell.classList.remove(\'highlight-move\',\'highlight-skill\',\'highlight-skill-target\',\'pulse\',\'highlight-tele\',\'highlight-imp\',\'highlight-stage\')); }\nfunction markCell(r,c,kind){\n  const cell=getCellEl(r,c);\n  if(cell && !cell.classList.contains(\'void\')){\n    cell.classList.add(kind===\'move\'?\'highlight-move\':(kind===\'target\'?\'highlight-skill-target\':\'highlight-skill\'));\n  }\n}\n\n// —— 回合与被动（含“恢复”/Neyla 保底/姿态结算） —— \nfunction applyParalysisAtTurnStart(side){\n  const team = Object.values(units).filter(u=>u.side===side && u.hp>0);\n  let totalPar = team.reduce((s,u)=> s + (u.status.paralyzed||0), 0);\n  if(totalPar>0){\n    if(side===\'player\'){ const before=playerSteps; playerSteps = Math.max(0, playerSteps - totalPar); appendLog(`恐惧/减步：玩家 -${totalPar} 步（${before} -> ${playerSteps}）`); }\n    else { const before=enemySteps; enemySteps = Math.max(0, enemySteps - totalPar); appendLog(`恐惧/减步：敌方 -${totalPar} 步（${before} -> ${enemySteps}）`); }\n    for(const u of team) u.status.paralyzed = 0;\n    updateStepsUI();\n  }\n}\nfunction avg(arr){ if(!arr || arr.length===0) return null; return Math.floor(arr.reduce((s,u)=>s+u.level,0)/arr.length); }\nfunction applyLevelSuppression(){\n  const playerAvg = avg(Object.values(units).filter(u=>u.side===\'player\' && u.hp>0));\n  const enemyAvg  = avg(Object.values(units).filter(u=>u.side===\'enemy\' && u.hp>0));\n  if(playerAvg===null||enemyAvg===null) return;\n  if(playerAvg>enemyAvg){ const add=Math.floor((playerAvg-enemyAvg)/5); if(add>0){ playerSteps += add; appendLog(`等级压制：玩家 +${add} 步`); } }\n  else if(enemyAvg>playerAvg){ const add=Math.floor((enemyAvg-playerAvg)/5); if(add>0){ enemySteps += add; appendLog(`敌方 +${add} 步（等级压制）`); } }\n  updateStepsUI();\n}\nfunction processUnitsTurnStart(side){\n  if(side===\'enemy\'){\n    if(roundsPassed % 2 === 0){\n      const haz = units[\'haz\'];\n      if(haz && haz.hp>0){ haz.sp = Math.min(haz.maxSp, haz.sp+10); syncSpBroken(haz); showGainFloat(haz,0,10); appendLog(\'队员们听令！Haz +10SP\'); }\n      for(const id in units){\n        const v=units[id]; if(v.team===\'seven\' && v.hp>0 && v.id!==\'haz\'){ v.sp = Math.min(v.maxSp, v.sp+5); syncSpBroken(v); showGainFloat(v,0,5); }\n      }\n      appendLog(\'队员们听令！其他队员 +5SP\');\n    }\n    if(roundsPassed >= 20){\n      for(const id of [\'katz\',\'tusk\',\'neyla\',\'kyn\']){\n        const v=units[id];\n        if(v && v.hp>0 && !v.oppression){\n          v.oppression = true;\n          v.skillPool.length = 0;\n          v.dealtStart = false;\n          ensureStartHand(v);\n          if(v.id===\'neyla\') ensureNeylaEndShadowGuarantee(v);\n          appendLog(`${v.name} 获得“队长的压迫”：开始使用禁忌技能`);\n        }\n      }\n    }\n  }\n\n  for(const id in units){\n    const u=units[id];\n    if(u.side!==side || u.hp<=0) continue;\n\n    u.actionsThisTurn = 0;\n    u.turnsStarted = (u.turnsStarted||0) + 1;\n\n    const extraDraw = Math.max(0, u.turnsStarted - 1);\n    if(extraDraw>0) drawSkills(u, extraDraw);\n\n    // Neyla 压迫后每回合保证“终末之影”在手牌，且最多一张\n    if(u.id===\'neyla\' && u.oppression){ ensureNeylaEndShadowGuarantee(u); }\n\n    // 姿态：回合开始时结算SP恢复与持续回合-1；结束时主动清除\n    if(u._stanceType && u._stanceTurns>0){\n      if(u._stanceSpPerTurn>0){\n        const beforeSP = u.sp;\n        u.sp = Math.min(u.maxSp, u.sp + u._stanceSpPerTurn);\n        syncSpBroken(u);\n        showGainFloat(u,0,u.sp-beforeSP);\n        appendLog(`${u.name} 的${u._stanceType===\'defense\'?\'防御\':\'反伤\'}姿态：+${u._stanceSpPerTurn} SP`);\n      }\n      u._stanceTurns = Math.max(0, u._stanceTurns - 1);\n      if(u._stanceTurns===0){\n        clearStance(u);\n      }\n    }\n\n    if(u.spPendingRestore!=null){\n      const val = Math.min(u.maxSp, u.spPendingRestore);\n      u.sp = val; syncSpBroken(u); u.spPendingRestore = null;\n      appendLog(`${u.name} 的 SP 自动恢复至 ${val}`); showGainFloat(u,0,val);\n      if(u.id===\'haz\'){\n        const heal = Math.max(1, Math.floor(u.maxHp*0.05));\n        u.hp = Math.min(u.maxHp, u.hp + heal);\n        appendLog(`Haz 因SP恢复同时回复 ${heal} HP`); showGainFloat(u,heal,0);\n      }\n    }\n\n    // “恢复”\n    if(u.status.recoverStacks && u.status.recoverStacks > 0){\n      const before = u.hp;\n      u.hp = Math.min(u.maxHp, u.hp + 5);\n      u.status.recoverStacks = Math.max(0, u.status.recoverStacks - 1);\n      showGainFloat(u,u.hp-before,0);\n      appendLog(`${u.name} 的“恢复”触发：+5HP（剩余 ${u.status.recoverStacks}）`);\n    }\n\n    if(u.status.bleed && u.status.bleed>0){\n      const bleedDmg = Math.max(1, Math.floor(u.maxHp*0.05));\n      damageUnit(u.id, bleedDmg, 0, `${u.name} 因流血受损`, null);\n      u.status.bleed = Math.max(0, u.status.bleed-1);\n    }\n    if(u.status.hazBleedTurns && u.status.hazBleedTurns>0){\n      const bleedDmg = Math.max(1, Math.floor(u.maxHp*0.03));\n      damageUnit(u.id, bleedDmg, 0, `${u.name} 因Haz流血受损`, null);\n      u.status.hazBleedTurns = Math.max(0, u.status.hazBleedTurns-1);\n    }\n\n    // 老的堡垒兼容（现在已由姿态系统取代）\n    if(u.id===\'tusk\' && u._fortressTurns>0){\n      u.sp = Math.min(u.maxSp, u.sp+10);\n      syncSpBroken(u);\n      showGainFloat(u,0,10);\n      u._fortressTurns--;\n    }\n  }\n\n  checkHazComebackStatus();\n}\nfunction processUnitsTurnEnd(side){\n  for(const id in units){\n    const u=units[id];\n    if(u.side!==side) continue;\n    if(u.id===\'adora\' && u.passives.includes(\'calmAnalysis\')){\n      if((u.actionsThisTurn||0)===0){\n        u.sp = Math.min(u.maxSp, u.sp + 10);\n        syncSpBroken(u);\n        appendLog(\'Adora 冷静分析：+10SP\'); showGainFloat(u,0,10);\n      }\n    }\n    if(u.id===\'karma\' && u.consecAttacks>0){ appendLog(\'Karma 连击在回合结束时重置\'); u.consecAttacks=0; }\n  }\n  for(const id in units){\n    const u=units[id];\n    if(u.side!==side) continue;\n    if(u.status.stunned>0){\n      const next = Math.max(0, u.status.stunned-1);\n      updateStatusStacks(u,\'stunned\', next, {label:\'眩晕\', type:\'debuff\'});\n      appendLog(`${u.name} 的眩晕减少 1（剩余 ${u.status.stunned}）`);\n    }\n  }\n}\nfunction applyEndOfRoundPassives(){\n  const adora = units[\'adora\'];\n  if(adora && adora.hp>0 && adora.passives.includes(\'proximityHeal\')){\n    for(const oid in units){\n      const v=units[oid];\n      if(!v || v.id===adora.id || v.side!==adora.side || v.hp<=0) continue;\n      if(Math.max(Math.abs(v.r-adora.r), Math.abs(v.c-adora.c)) <= 3){\n        const heal = Math.max(1, Math.floor(v.maxHp*0.05));\n        v.hp = Math.min(v.maxHp, v.hp + heal);\n        v.sp = Math.min(v.maxSp, v.sp + 5);\n        syncSpBroken(v);\n        appendLog(`Adora 邻近治疗：为 ${v.name} 恢复 ${heal} HP 和 5 SP`);\n        showGainFloat(v,heal,5);\n      }\n    }\n  }\n}\nfunction finishEnemyTurn(){\n  clearAIWatchdog();\n  processUnitsTurnEnd(\'enemy\');\n  roundsPassed += 1;\n  applyEndOfRoundPassives();\n\n  updateStepsUI();\n  setTimeout(()=>{\n    currentSide=\'player\';\n    playerSteps=computeBaseSteps();\n    if(playerBonusStepsNextTurn>0){\n      const bonus = playerBonusStepsNextTurn;\n      playerSteps += bonus;\n      appendLog(`先苦后甜：玩家额外 +${bonus} 步`);\n      playerBonusStepsNextTurn = 0;\n    }\n    appendLog(\'敌方回合结束，玩家回合开始\');\n    applyLevelSuppression();\n    applyParalysisAtTurnStart(\'player\');\n    processUnitsTurnStart(\'player\');\n    renderAll();\n  }, 300);\n}\nfunction endTurn(){\n  clearAllSelection();\n  if(currentSide===\'player\'){\n    appendLog(\'玩家结束回合\');\n    playerSteps = 0;\n    updateStepsUI();\n    checkEndOfTurn();\n  } else {\n    appendLog(\'敌方结束回合\');\n    // finishEnemyTurn() 会在敌方步数已被耗尽时被调用\n    finishEnemyTurn();\n  }\n}\n\n// —— 敌方 AI：保证用尽全部步数（无技能时必向玩家逼近） —— \nfunction distanceForAI(u,target){\n  const baseR = u.size===2 ? (u.r+0.5) : u.r;\n  const baseC = u.size===2 ? (u.c+0.5) : u.c;\n  return Math.abs(baseR - target.r) + Math.abs(baseC - target.c);\n}\nfunction isWalkableForUnit(u, r, c){\n  if(u.size===2) return canPlace2x2(u, r, c);\n  if(!clampCell(r,c)) return false;\n  const occ = getUnitAt(r,c);\n  return !occ || occ===u;\n}\nfunction neighborsOf(u, r, c){\n  const res=[];\n  for(const dir of Object.keys(DIRS)){\n    const d=DIRS[dir];\n    const rr=r+d.dr, cc=c+d.dc;\n    if(isWalkableForUnit(u, rr, cc)) res.push({r:rr, c:cc, dir});\n  }\n  return res;\n}\nfunction goalAdjCellsForTargets(u, targets){\n  const goals=[];\n  const seen=new Set();\n  for(const t of targets){\n    const adj = range_adjacent(t);\n    for(const p of adj){\n      const k=`${p.r},${p.c}`;\n      if(seen.has(k)) continue;\n      if(isWalkableForUnit(u, p.r, p.c) && !getUnitAt(p.r,p.c)){\n        goals.push({r:p.r, c:p.c});\n        seen.add(k);\n      }\n    }\n  }\n  return goals;\n}\nfunction bfsNextStepTowardAny(u, targets, maxExplore=4000){\n  const goals = goalAdjCellsForTargets(u, targets);\n  if(goals.length===0) return null;\n  const goalSet = new Set(goals.map(g=>`${g.r},${g.c}`));\n\n  const q=[];\n  const prev=new Map();\n  const startKey = `${u.r},${u.c}`;\n  q.push({r:u.r, c:u.c});\n  prev.set(startKey, null);\n  let foundKey=null;\n\n  while(q.length && prev.size < maxExplore){\n    const cur=q.shift();\n    const ck=`${cur.r},${cur.c}`;\n    if(goalSet.has(ck)){ foundKey=ck; break; }\n    const ns = neighborsOf(u, cur.r, cur.c);\n    for(const n of ns){\n      const nk=`${n.r},${n.c}`;\n      if(!prev.has(nk)){\n        prev.set(nk, ck);\n        q.push({r:n.r, c:n.c});\n      }\n    }\n  }\n  if(!foundKey) return null;\n\n  let stepKey=foundKey, back=prev.get(stepKey);\n  while(back && back!==startKey){\n    stepKey = back;\n    back = prev.get(stepKey);\n  }\n  const [sr, sc] = (back===null? foundKey : stepKey).split(\',\').map(Number);\n  const dir = cardinalDirFromDelta(sr - u.r, sc - u.c);\n  return {r:sr, c:sc, dir};\n}\nfunction tryStepsToward(u, target){\n  const prefs=[];\n  const baseC = u.size===2 ? (u.c+0.5) : u.c;\n  const baseR = u.size===2 ? (u.r+0.5) : u.r;\n  const dc=Math.sign(target.c - baseC);\n  const dr=Math.sign(target.r - baseR);\n  if(Math.abs(target.c-baseC) >= Math.abs(target.r-baseR)){\n    if(dc!==0) prefs.push(dc>0?\'right\':\'left\');\n    if(dr!==0) prefs.push(dr>0?\'down\':\'up\');\n  } else {\n    if(dr!==0) prefs.push(dr>0?\'down\':\'up\');\n    if(dc!==0) prefs.push(dc>0?\'right\':\'left\');\n  }\n  for(const k of [\'up\',\'down\',\'left\',\'right\']) if(!prefs.includes(k)) prefs.push(k);\n\n  for(const dir of prefs){\n    const cand = forwardCellAt(u,dir,1);\n    if(!cand) continue;\n    if(u.size===2){\n      if(canPlace2x2(u, cand.r, cand.c)){ u.r=cand.r; u.c=cand.c; setUnitFacing(u, dir); return {moved:true}; }\n    } else {\n      if(!getUnitAt(cand.r,cand.c)){ u.r=cand.r; u.c=cand.c; setUnitFacing(u, dir); return {moved:true}; }\n    }\n  }\n  return {moved:false};\n}\nfunction computeRallyPoint(){\n  const haz = units[\'haz\'];\n  if(haz && haz.hp>0) return {r:haz.r, c:haz.c};\n  const allies = Object.values(units).filter(x=>x.side===\'enemy\' && x.hp>0);\n  if(allies.length===0) return {r:10,c:10};\n  const avgR = Math.round(allies.reduce((s,a)=>s+a.r,0)/allies.length);\n  const avgC = Math.round(allies.reduce((s,a)=>s+a.c,0)/allies.length);\n  return {r:avgR, c:avgC};\n}\nfunction computeCellsForSkill(u, sk, dir){\n  try{ return sk.rangeFn(u, dir||u.facing, null) || []; }catch(e){ return []; }\n}\nfunction aiAwait(ms){ return new Promise(res=>setTimeout(res, ms)); }\n\nfunction enemyLivingEnemies(){ return Object.values(units).filter(u=>u.side===\'enemy\' && u.hp>0); }\nfunction enemyLivingPlayers(){ return Object.values(units).filter(u=>u.side===\'player\' && u.hp>0); }\n\nfunction buildSkillCandidates(en){\n  const skillset = (en.skillPool && en.skillPool.length) ? en.skillPool : [];\n  const candidates=[];\n  for(const sk of skillset){\n    if(sk.cost>enemySteps) continue;\n    try{\n      // 自我增益先（锁链缠绕/堡垒/反伤）\n      const selfCells = sk.rangeFn(en, en.facing, null) || [];\n      const isSelfOnly = selfCells.length>0 && selfCells.every(c=>c.r===en.r && c.c===en.c);\n      const isBuffName = [\'锁链缠绕\',\'战争堡垒\',\'拼尽全力保卫队长\'].includes(sk.name);\n      const canUseBuff = isBuffName && ((sk.name===\'锁链缠绕\' && en.chainShieldTurns<=0) || (!en._stanceType || en._stanceTurns<=0));\n      if(isSelfOnly && isBuffName && canUseBuff){\n        candidates.push({sk, dir:en.facing, score: 22}); // 自保最高\n        continue;\n      }\n\n      const dirs = Object.keys(DIRS);\n      const isAdjSkill = [\'鱼叉穿刺\',\'骨盾猛击\',\'沙包大的拳头\',\'短匕轻挥\'].includes(sk.name);\n      if(isAdjSkill){\n        const adj = range_adjacent(en);\n        for(const c of adj){\n          const tu=getUnitAt(c.r,c.c);\n          if(tu && tu.side===\'player\'){ candidates.push({sk, dir:c.dir, targetUnit:tu, score: 16}); }\n        }\n      } else if(sk.meta && sk.meta.cellTargeting){\n        const cells = sk.rangeFn(en, en.facing, null) || [];\n        let best=null, bestScore=-1;\n        for(const c of cells){\n          const tu=getUnitAt(c.r,c.c);\n          if(tu && tu.side===\'player\' && tu.hp>0){\n            const hpRatio = tu.hp/tu.maxHp;\n            const sc = 18 + Math.floor((1-hpRatio)*20);\n            if(sc>bestScore){ bestScore=sc; best={sk, targetUnit:tu, score:sc}; }\n          }\n        }\n        if(best) candidates.push(best);\n      } else {\n        for(const d of dirs){\n          const cells = sk.rangeFn(en,d,null) || [];\n          let hits=0, set=new Set();\n          for(const c of cells){\n            const tu=getUnitAt(c.r,c.c);\n            if(tu && tu.side===\'player\' && !set.has(tu.id)){ set.add(tu.id); hits++; }\n          }\n          if(hits>0) candidates.push({sk, dir:d, score: 10 + hits*8});\n        }\n      }\n    } catch(e){\n      console.error(\'AI 技能评估错误\', e);\n      appendLog(`[AI错误] ${en.name} 评估 ${sk.name} 失败：${e.message}`);\n    }\n  }\n  candidates.sort((a,b)=> b.score-a.score);\n  return candidates;\n}\nasync function execEnemySkillCandidate(en, cand){\n  enemySteps = Math.max(0, enemySteps - cand.sk.cost);\n  updateStepsUI();\n\n  const cells = cand.targetUnit\n    ? [{r:cand.targetUnit.r, c:cand.targetUnit.c}]\n    : computeCellsForSkill(en, cand.dir, cand.dir);\n\n  clearHighlights();\n  cells.forEach(c=> markCell(c.r,c.c,\'skill\'));\n  await aiAwait(ENEMY_WINDUP_MS);\n  clearHighlights();\n\n  let faceDir = null;\n  if(cand.targetUnit){\n    const tu = cand.targetUnit;\n    if(tu.r !== en.r || tu.c !== en.c){\n      faceDir = cardinalDirFromDelta(tu.r - en.r, tu.c - en.c);\n    }\n  } else if(cand.dir){\n    faceDir = cand.dir;\n  }\n  if(faceDir){\n    setUnitFacing(en, faceDir);\n  }\n\n  try{\n    if(cand.targetUnit && cand.sk.meta && cand.sk.meta.cellTargeting){\n      await cand.sk.execFn(en, {r:cand.targetUnit.r, c:cand.targetUnit.c});\n    } else if(cand.targetUnit){\n      await cand.sk.execFn(en, cand.targetUnit);\n    } else if(cand.sk.estimate && cand.sk.estimate.aoe){\n      await cand.sk.execFn(en, {dir:cand.dir});\n    } else {\n      await cand.sk.execFn(en, {dir:cand.dir});\n    }\n    consumeCardFromHand(en, cand.sk);\n    renderAll();\n    return true;\n  } catch(e){\n    console.error(\'AI 技能施放错误\', e);\n    appendLog(`[AI错误] ${en.name} 施放 ${cand.sk.name} 失败：${e.message}`);\n    return false;\n  }\n}\nfunction stepTowardNearestPlayer(en){\n  if(!canUnitMove(en)) return false;\n  const players = enemyLivingPlayers();\n  if(players.length===0) return false;\n  // BFS toward any player\'s adjacent cell\n  const step = bfsNextStepTowardAny(en, players);\n  if(step){\n    setUnitFacing(en, step.dir || en.facing);\n    en.r = step.r; en.c = step.c;\n    enemySteps = Math.max(0, enemySteps - 1);\n    updateStepsUI();\n    cameraFocusOnCell(en.r,en.c);\n    renderAll();\n    appendLog(`${en.name} 逼近：向玩家方向移动 1 步`);\n    return true;\n  }\n  // Fallback heuristic toward nearest player\'s position\n  let nearest=players[0], md=distanceForAI(en, players[0]);\n  for(const p of players){ const d=distanceForAI(en,p); if(d<md){ md=d; nearest=p; } }\n  const mv = tryStepsToward(en, nearest);\n  if(mv.moved){\n    enemySteps = Math.max(0, enemySteps - 1);\n    updateStepsUI();\n    cameraFocusOnCell(en.r,en.c);\n    renderAll();\n    appendLog(`${en.name} 逼近：向最近玩家挪动 1 步`);\n    return true;\n  }\n  return false;\n}\nfunction wasteOneEnemyStep(reason=\'敌方犹豫不决，浪费了 1 步\'){\n  if(enemySteps>0){\n    enemySteps = Math.max(0, enemySteps - 1);\n    appendLog(reason);\n    updateStepsUI();\n    return true;\n  }\n  return false;\n}\n\nasync function exhaustEnemySteps(){\n  aiLoopToken++; const token = aiLoopToken;\n  armAIWatchdog(token, 20000);\n\n  // 主循环：直到步数归零或一方全灭\n  while(currentSide===\'enemy\' && enemySteps>0){\n    if(token !== aiLoopToken) break;\n\n    // 快速终止条件\n    const livingEnemies = enemyLivingEnemies();\n    const players = enemyLivingPlayers();\n    if(livingEnemies.length===0 || players.length===0){\n      enemySteps = 0;\n      updateStepsUI();\n      break;\n    }\n\n    let progressedThisRound = false;\n\n    // 轮询每个单位各尝试一次“动作”\n    for(const en of livingEnemies){\n      if(enemySteps<=0) break;\n      if(!en || en.hp<=0) continue;\n      if(en.status.stunned){ aiLog(en,\'眩晕跳过\'); continue; }\n      if(!en.dealtStart) ensureStartHand(en);\n      if(en.id===\'neyla\' && en.oppression) ensureNeylaEndShadowGuarantee(en);\n\n      // 1) 尝试技能\n      let didAct = false;\n      const candidates = buildSkillCandidates(en);\n      if(candidates.length>0){\n        didAct = await execEnemySkillCandidate(en, candidates[0]);\n        if(didAct) progressedThisRound = true;\n      }\n\n      // 2) 无技能可用 → 向玩家移动\n      if(!didAct && enemySteps>0){\n        const moved = stepTowardNearestPlayer(en);\n        if(moved){\n          progressedThisRound = true;\n          await aiAwait(140);\n        }\n      }\n\n      // 3) 仍无动作 → 尝试原地随机挪步（只为消步）\n      if(!didAct && enemySteps>0 && !progressedThisRound){\n        const neigh = neighborsOf(en, en.r, en.c).filter(p=> !getUnitAt(p.r,p.c));\n        if(canUnitMove(en) && neigh.length){\n          const pick = neigh[Math.floor(Math.random()*neigh.length)];\n          en.r = pick.r; en.c = pick.c;\n          setUnitFacing(en, pick.dir || en.facing);\n          enemySteps = Math.max(0, enemySteps - 1);\n          updateStepsUI();\n          cameraFocusOnCell(en.r,en.c);\n          renderAll();\n          appendLog(`${en.name} 试探性移动：消耗 1 步`);\n          progressedThisRound = true;\n          await aiAwait(120);\n        }\n      }\n    }\n\n    // 整轮无人动作 → 强行消步直到 0（防止卡住）\n    if(!progressedThisRound){\n      // 尝试对一个可移动单位强制朝集合点靠拢\n      const anyMovable = enemyLivingEnemies().find(e=> canUnitMove(e) && neighborsOf(e, e.r, e.c).some(p=>!getUnitAt(p.r,p.c)));\n      if(anyMovable){\n        const rally = computeRallyPoint();\n        const mv = tryStepsToward(anyMovable, rally);\n        if(mv.moved){\n          enemySteps = Math.max(0, enemySteps - 1);\n          updateStepsUI();\n          cameraFocusOnCell(anyMovable.r,anyMovable.c);\n          renderAll();\n          appendLog(`${anyMovable.name} 整队：向集合点挪动 1 步`);\n          await aiAwait(120);\n          continue; // 继续下一轮\n        }\n      }\n      // 仍无法动作 → 直接丢弃步数\n      if(enemySteps>0){\n        wasteOneEnemyStep();\n        await aiAwait(80);\n      }\n    }\n  }\n\n  clearAIWatchdog();\n}\n\nasync function enemyTurn(){\n  renderAll();\n  const livingEnemies = enemyLivingEnemies();\n  const livingPlayers = enemyLivingPlayers();\n  if(livingEnemies.length===0 || livingPlayers.length===0){\n    enemySteps = 0; updateStepsUI();\n    return finishEnemyTurn();\n  }\n  appendLog(\'敌方开始行动\');\n\n  enemyActionCameraLock = true;\n\n  // 用尽步数\n  await exhaustEnemySteps();\n\n  // 兜底：确保步数为 0\n  if(enemySteps>0){\n    appendLog(\'兜底：将剩余敌方步数清零\');\n    enemySteps = 0; updateStepsUI();\n  }\n\n  enemyActionCameraLock = false;\n  cameraReset();\n\n  // 正式结束敌方回合\n  finishEnemyTurn();\n}\n\n// —— 胜负/渲染循环 ——\nfunction checkWin(){\n  const enemiesAlive = Object.values(units).some(u=>u.side===\'enemy\' && u.hp>0);\n  const playersAlive = Object.values(units).some(u=>u.side===\'player\' && u.hp>0);\n  if(!enemiesAlive){ showAccomplish(); return true; }\n  if(!playersAlive){ \n    appendLog(\'全灭，失败\');\n    showDefeatScreen();\n    return true; \n  }\n  return false;\n}\nfunction showAccomplish(){\n  // Stop boss BGM when battle is won\n  try {\n    if (window.__GW_AUDIO__ && window.__GW_AUDIO__.forceSilenceBossBGM) {\n      window.__GW_AUDIO__.forceSilenceBossBGM();\n    }\n  } catch (e) {\n    console.error('Failed to stop boss BGM:', e);\n  }\n  if(!accomplish) return;\n  accomplish.classList.remove(\'hidden\');\n  if(damageSummary){\n    damageSummary.innerHTML=\'\';\n    const wrap=document.createElement(\'div\'); wrap.className=\'acctable\';\n    for(const id of [\'adora\',\'dario\',\'karma\']){\n      const u=units[id];\n      const row=document.createElement(\'div\'); row.className=\'row\';\n      row.innerHTML=`<strong>${u.name}<\/strong><div class="small">造成伤害: ${u.dmgDone}，受到: ${u.maxHp - u.hp}<\/div>`;\n      wrap.appendChild(row);\n    }\n    damageSummary.appendChild(wrap);\n  }\n  const btn=document.getElementById(\'confirmBtn\');\n  if(btn) btn.onclick=()=>{ \n    accomplish.classList.add(\'hidden\'); \n    appendLog(\'通关!\'); \n    // Return to stage selection after victory\n    setTimeout(() => {\n      window.location.href = \'../Menu/index.html\';\n    }, 500);\n  };\n}\nfunction showDefeatScreen(){\n  // Stop boss BGM when battle is lost\n  try {\n    if (window.__GW_AUDIO__ && window.__GW_AUDIO__.forceSilenceBossBGM) {\n      window.__GW_AUDIO__.forceSilenceBossBGM();\n    }\n  } catch (e) {\n    console.error('Failed to stop boss BGM:', e);\n  }\n  // Show defeat message and return to stage selection\n  const defeatMsg = \'战斗失败！即将返回关卡界面...\';\n  appendLog(defeatMsg);\n  \n  // Create a simple defeat overlay or use the accomplish modal\n  if(accomplish){\n    accomplish.classList.remove(\'hidden\');\n    const modalContent = accomplish.querySelector(\'.modal-content\');\n    if(modalContent){\n      modalContent.querySelector(\'h2\').textContent = \'战斗失败\';\n      if(damageSummary) damageSummary.innerHTML = \'<p>全军覆没，请重新尝试。<\/p>\';\n    }\n    const btn=document.getElementById(\'confirmBtn\');\n    if(btn){\n      btn.textContent = \'返回关卡\';\n      btn.onclick=()=>{ \n        accomplish.classList.add(\'hidden\');\n        // Return to stage selection after defeat\n        setTimeout(() => {\n          window.location.href = \'../Menu/index.html\';\n        }, 300);\n      };\n    }\n  } else {\n    // Fallback: direct redirect after delay\n    setTimeout(() => {\n      window.location.href = \'../Menu/index.html\';\n    }, 2000);\n  }\n}\nfunction renderAll(){\n  buildGrid();\n  placeUnits();\n  renderStatus();\n  updateStepsUI();\n  if(checkWin()) return;\n}\nfunction checkEndOfTurn(){\n  if(currentSide===\'player\' && playerSteps<=0){\n    appendLog(\'玩家步数耗尽，轮到敌方\');\n    processUnitsTurnEnd(\'player\');\n    currentSide=\'enemy\';\n    enemySteps=computeBaseSteps();\n    applyLevelSuppression();\n    applyParalysisAtTurnStart(\'enemy\');\n    processUnitsTurnStart(\'enemy\');\n    // 敌方回合：保证用尽步数\n    setTimeout(()=>{ enemyTurn(); }, 200);\n    return;\n  }\n  if(currentSide===\'enemy\' && enemySteps<=0){\n    appendLog(\'敌方步数耗尽，轮到玩家\');\n    finishEnemyTurn();\n    return;\n  }\n}\n\n// —— Haz 力挽狂澜触发检测（含卡池替换规则） —— \nfunction checkHazComebackStatus(){\n  const haz = units[\'haz\'];\n  if(!haz || haz.hp<=0) return;\n  const others = Object.values(units).filter(v=>v.side===\'enemy\' && v.hp>0 && v.id!==\'haz\');\n  const shouldActive = (others.length===0);\n  if(shouldActive && !haz._comeback){\n    haz._comeback = true;\n\n    if(haz.skillPool && haz.skillPool.length){\n      haz.skillPool = haz.skillPool.filter(sk => sk.name === \'深海猎杀\');\n    } else {\n      haz.skillPool = [];\n    }\n    const need = Math.max(0, START_HAND_COUNT - haz.skillPool.length);\n    drawSkills(haz, need);\n\n    appendLog(\'Haz 被动「力挽狂澜」觉醒：伤害+10%，所受伤害-10%，卡池已替换为「深海猎杀 + 力挽狂澜禁招」，其他原始技能出现几率为 0\');\n  }\n}\n\n// —— 初始化 —— \ndocument.addEventListener(\'DOMContentLoaded\', ()=>{\n  battleAreaEl = document.getElementById(\'battleArea\');\n  mapPaneEl = document.getElementById(\'mapPane\');\n  cameraEl = battleAreaEl;\n  playerStepsEl = document.getElementById(\'playerSteps\');\n  enemyStepsEl = document.getElementById(\'enemySteps\');\n  roundCountEl = document.getElementById(\'roundCount\');\n  partyStatus = document.getElementById(\'partyStatus\');\n  selectedInfo = document.getElementById(\'selectedInfo\');\n  skillPool = document.getElementById(\'skillPool\');\n  logEl = document.getElementById(\'log\');\n  accomplish = document.getElementById(\'accomplish\');\n  damageSummary = document.getElementById(\'damageSummary\');\n\n  updateCameraBounds();\n  createCameraControls();\n  registerCameraInputs();\n  cameraReset({immediate:true});\n  startCameraLoop();\n\n  // 掩体（不可进入）\n  addCoverRectBL(2,3,4,5);\n  addCoverRectBL(2,12,5,14);\n  addCoverRectBL(10,11,12,13);\n\n  injectFXStyles();\n\n  // 起手手牌\n  for(const id in units){ const u=units[id]; if(u.hp>0) ensureStartHand(u); }\n\n  playerSteps = computeBaseSteps();\n  enemySteps = computeBaseSteps();\n\n  renderAll();\n  updateCameraBounds();\n  applyCameraTransform();\n\n  // 初次渲染后延迟刷新 2x2 覆盖\n  setTimeout(()=> refreshLargeOverlays(), 0);\n  setTimeout(()=> refreshLargeOverlays(), 240);\n  if(\'requestAnimationFrame\' in window){\n    requestAnimationFrame(()=> refreshLargeOverlays());\n  }\n  window.addEventListener(\'load\', ()=> refreshLargeOverlays());\n\n  appendLog(\'七海作战队 Boss 战开始：地图 18x22，右下角 8x10 空缺；掩体为不可进入。\');\n  appendLog(\'叠层眩晕：精英2层（Kyn/Neyla）；小Boss3层（Tusk/Katz）；Boss4层（Haz）。SP崩溃直接眩晕且下回合自动回蓝。\');\n  appendLog(\'敌方攻击带预警并有较长前摇；AOE 预警为青色、命中为红色；多阶段技能逐段即时结算并以黄色标记上一段受击区。\');\n  appendLog(\'保证：敌方在回合结束前必定将步数耗尽；若无法施放技能，则必定向玩家单位移动或消步。\');\n  appendLog(\'每个来回计 1 回合；20 回合后触发“队长的压迫”。\');\n\n  const endTurnBtn=document.getElementById(\'endTurnBtn\');\n  if(endTurnBtn) endTurnBtn.addEventListener(\'click\', ()=>{ if(interactionLocked) return; endTurn(); });\n\n  // GOD\'S WILL 按钮\n  godsWillBtn = document.createElement(\'button\');\n  godsWillBtn.id = \'godsWillBtn\';\n  godsWillBtn.textContent = "GOD\'S WILL";\n  godsWillBtn.title = \'调试：点击后选择任意单位 → 杀死或留 1 HP（ESC 取消）\';\n  godsWillBtn.onclick = (e)=>{\n    e.stopPropagation();\n    if(interactionLocked || godsWillLockedOut) return;\n    if(!godsWillUnlocked){\n      const answer = prompt(\'请输入 GOD\\\'S WILL 密码\');\n      const normalized = (answer ?? \'\').trim();\n      if(normalized === GODS_WILL_PASSWORD){\n        godsWillUnlocked = true;\n        if(godsWillBtn){\n          godsWillBtn.disabled = false;\n          godsWillBtn.classList.remove(\'locked\');\n          godsWillBtn.title = \'GOD’S WILL：点击后选择任意单位 → 杀死或留 1 HP（ESC 取消）\';\n        }\n        appendLog(\'GOD’S WILL：密码验证通过，功能解锁\');\n      } else {\n        godsWillLockedOut = true;\n        if(godsWillBtn){\n          godsWillBtn.disabled = true;\n          godsWillBtn.classList.add(\'locked\');\n          godsWillBtn.title = \'GOD’S WILL：密码错误，功能已锁定\';\n        }\n        appendLog(\'GOD’S WILL：密码错误，按钮失效\');\n        return;\n      }\n    }\n    toggleGodsWill();\n  };\n  document.body.appendChild(godsWillBtn);\n\n  // Full Screen 按钮\n  fsBtn = document.createElement(\'button\');\n  fsBtn.id = \'fullscreenBtn\';\n  fsBtn.textContent = \'Full Screen\';\n  fsBtn.title = \'切换全屏模式\';\n  fsBtn.onclick = (e)=>{ e.stopPropagation(); if(interactionLocked) return; toggleFullscreen(); };\n  document.body.appendChild(fsBtn);\n\n  // ESC 取消 GOD’S WILL\n  window.addEventListener(\'keydown\',(e)=>{\n    if(e.key === \'Escape\' && godsWillArmed){\n      disarmGodsWill();\n    }\n  });\n\n  // 视口改变时刷新 2x2 覆盖和菜单\n  let _resizeTimer=null;\n  window.addEventListener(\'resize\', ()=>{\n    if(_resizeTimer) clearTimeout(_resizeTimer);\n    _resizeTimer = setTimeout(()=>{\n      refreshLargeOverlays();\n      if(godsWillMenuEl && godsWillMenuEl.isConnected){\n        godsWillMenuEl.remove();\n        godsWillMenuEl=null;\n        if(godsWillArmed) appendLog(\'GOD’S WILL 菜单因窗口变化已移除，请重新点击单位\');\n      }\n      updateCameraBounds();\n    }, 120);\n  });\n\n  applyLevelSuppression();\n  applyParalysisAtTurnStart(\'player\');\n  processUnitsTurnStart(\'player\');\n  updateStepsUI();\n  setTimeout(()=> playIntroCinematic(), 80);\n});\n\n<\/script>\n<\/body>\n<\/html>';
